// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts/governance/utils/IVotes.sol";
import "@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol";
import "@openzeppelin/contracts/interfaces/IERC6372.sol";
import "../interfaces/IHyraGovernor.sol";
import "../security/MultiSigRoleManager.sol";
import "../security/TimeLockActions.sol";

/**
 * @title SecureHyraGovernor
 * @notice Secure DAO governance contract with multi-signature role management
 * @dev This contract replaces the centralized _governance role with multi-signature requirements
 *      All privileged operations now require multiple signatures and time delays
 */
contract SecureHyraGovernor is
    Initializable,
    ReentrancyGuardUpgradeable,
    GovernorUpgradeable,
    GovernorSettingsUpgradeable,
    GovernorCountingSimpleUpgradeable,
    GovernorVotesUpgradeable,
    GovernorVotesQuorumFractionUpgradeable,
    GovernorTimelockControlUpgradeable,
    IHyraGovernor
{   
    // ============ State Variables ============
    mapping(uint256 => ProposalType) public proposalTypes;
    mapping(uint256 => bool) public proposalCancelled;
    mapping(address => bool) public securityCouncilMembers;
    mapping(uint256 => address) private _proposalProposers;
    uint256 public securityCouncilMemberCount;
    
    // Security contracts
    MultiSigRoleManager public roleManager;
    TimeLockActions public timeLockActions;
    
    // Quorum percentages (basis points)
    uint256 public constant STANDARD_QUORUM = 1000; // 10%
    uint256 public constant EMERGENCY_QUORUM = 1500; // 15%
    uint256 public constant CONSTITUTIONAL_QUORUM = 3000; // 30%
    uint256 public constant UPGRADE_QUORUM = 2500; // 25%
    
    // Storage gap for upgradeability
    uint256[42] private __gap;

    // ============ Events ============
    event ProposalTypeSet(uint256 indexed proposalId, ProposalType proposalType);
    event ProposalCancelled(uint256 indexed proposalId);
    event SecurityCouncilMemberAdded(address indexed member);
    event SecurityCouncilMemberRemoved(address indexed member);
    event ProposalCreatedWithType(
        uint256 indexed proposalId,
        address proposer,
        ProposalType proposalType
    );
    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);
    event VoteCasted(address indexed voter, uint256 proposalId, uint8 support, uint256 weight);
    event SecurityContractsUpdated(address indexed roleManager, address indexed timeLockActions);

    // ============ Errors ============
    error InvalidProposalType();
    error OnlySecurityCouncil();
    error NotSecurityCouncilMember();
    error AlreadySecurityCouncilMember();
    error ProposalAlreadyCancelled();
    error UnauthorizedCancellation();
    error InvalidProposalLength();
    error ZeroAddress();
    error ProposalNotFound();
    error VotingNotActive();
    error InvalidSecurityContract();
    error ActionNotReady(bytes32 actionHash);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    /**
     * @notice Initialize the Secure Governor contract
     * @param name_ Name of the governance token
     * @param version_ Version of the governance contract
     * @param token_ Address of the voting token
     * @param timelock_ Address of the timelock controller
     * @param _roleManager Address of the MultiSigRoleManager
     * @param _timeLockActions Address of the TimeLockActions contract
     */
    function initialize(
        string memory name_,
        string memory version_,
        IVotes token_,
        TimelockControllerUpgradeable timelock_,
        address _roleManager,
        address _timeLockActions
    ) public initializer {
        __Governor_init(name_);
        __GovernorSettings_init(1, 172800, 10000000000000000000000); // 1 block voting delay, 2 days voting period, 10 token voting threshold
        __GovernorCountingSimple_init();
        __GovernorVotes_init(token_);
        __GovernorVotesQuorumFraction_init(4); // 4% quorum
        __GovernorTimelockControl_init(timelock_);
        __ReentrancyGuard_init();
        
        if (_roleManager == address(0) || _timeLockActions == address(0)) {
            revert ZeroAddress();
        }
        
        roleManager = MultiSigRoleManager(_roleManager);
        timeLockActions = TimeLockActions(_timeLockActions);
        
        emit SecurityContractsUpdated(_roleManager, _timeLockActions);
    }

    /**
     * @notice Create a proposal with a specific type
     * @param targets Array of target addresses
     * @param values Array of ETH values
     * @param calldatas Array of calldata
     * @param description Description of the proposal
     * @param proposalType Type of the proposal
     * @return proposalId The ID of the created proposal
     */
    function proposeWithType(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description,
        ProposalType proposalType
    ) public override returns (uint256) {
        if (targets.length == 0 || targets.length > 10) {
            revert InvalidProposalLength();
        }
        
        // Check if proposer has the required role
        bytes32 requiredRole = _getRequiredRoleForProposalType(proposalType);
        if (!roleManager.hasRole(requiredRole, msg.sender)) {
            revert UnauthorizedCancellation();
        }
        
        uint256 proposalId = super.propose(targets, values, calldatas, description);
        
        proposalTypes[proposalId] = proposalType;
        _proposalProposers[proposalId] = msg.sender;
        
        emit ProposalTypeSet(proposalId, proposalType);
        emit ProposalCreatedWithType(proposalId, msg.sender, proposalType);
        
        return proposalId;
    }

    /**
     * @notice Cancel a proposal
     * @param targets Array of target addresses
     * @param values Array of ETH values
     * @param calldatas Array of calldata
     * @param descriptionHash Hash of the description
     * @return proposalId The ID of the cancelled proposal
     */
    function cancel(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) public override(GovernorUpgradeable, IGovernor) nonReentrant returns (uint256) {
        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);
        
        ProposalState currentState = state(proposalId);
        if (currentState == ProposalState.Canceled) {
            revert ProposalAlreadyCancelled();
        }
        
        // Check authorization - proposer or security council can cancel
        address proposer = proposalProposer(proposalId);
        if (msg.sender != proposer && !securityCouncilMembers[msg.sender]) {
            revert UnauthorizedCancellation();
        }
        
        // For security council members, bypass parent authorization
        if (securityCouncilMembers[msg.sender]) {
            // Directly call internal _cancel function
            _cancel(targets, values, calldatas, descriptionHash);
            proposalCancelled[proposalId] = true;
            emit ProposalCancelled(proposalId);
            return proposalId;
        } else {
            // For proposers, use parent function
            uint256 result = super.cancel(targets, values, calldatas, descriptionHash);
            proposalCancelled[proposalId] = true;
            emit ProposalCancelled(proposalId);
            return result;
        }
    }

    // ============ Security Council Functions ============

    /**
     * @notice Add a security council member (requires multi-signature)
     * @param _member Address to add
     */
    function addSecurityCouncilMember(address _member) 
        external 
        override
    {
        if (_member == address(0)) revert ZeroAddress();
        if (securityCouncilMembers[_member]) revert AlreadySecurityCouncilMember();
        
        // This function now requires multi-signature approval through TimeLockActions
        bytes memory data = abi.encodeWithSelector(
            this._addSecurityCouncilMember.selector,
            _member
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.GOVERNANCE_ROLE(),
            0 // Use default delay
        );
        
        // The actual execution will happen through executeAction
    }
    
    /**
     * @notice Internal function to add security council member (called by TimeLockActions)
     * @param _member Address to add
     */
    function _addSecurityCouncilMember(address _member) external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        securityCouncilMembers[_member] = true;
        securityCouncilMemberCount++;
        
        emit SecurityCouncilMemberAdded(_member);
    }

    /**
     * @notice Remove a security council member (requires multi-signature)
     * @param _member Address to remove
     */
    function removeSecurityCouncilMember(address _member) 
        external 
        override
    {
        if (!securityCouncilMembers[_member]) revert NotSecurityCouncilMember();
        
        // This function now requires multi-signature approval through TimeLockActions
        bytes memory data = abi.encodeWithSelector(
            this._removeSecurityCouncilMember.selector,
            _member
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.GOVERNANCE_ROLE(),
            0 // Use default delay
        );
    }
    
    /**
     * @notice Internal function to remove security council member (called by TimeLockActions)
     * @param _member Address to remove
     */
    function _removeSecurityCouncilMember(address _member) external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        securityCouncilMembers[_member] = false;
        securityCouncilMemberCount--;
        
        emit SecurityCouncilMemberRemoved(_member);
    }

    /**
     * @notice Update security contracts (requires multi-signature)
     * @param _roleManager New role manager address
     * @param _timeLockActions New time lock actions address
     */
    function updateSecurityContracts(
        address _roleManager,
        address _timeLockActions
    ) external {
        if (_roleManager == address(0) || _timeLockActions == address(0)) {
            revert ZeroAddress();
        }
        
        // This function requires multi-signature approval
        bytes memory data = abi.encodeWithSelector(
            this._updateSecurityContracts.selector,
            _roleManager,
            _timeLockActions
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.GOVERNANCE_ROLE(),
            0 // Use default delay
        );
    }
    
    /**
     * @notice Internal function to update security contracts (called by TimeLockActions)
     * @param _roleManager New role manager address
     * @param _timeLockActions New time lock actions address
     */
    function _updateSecurityContracts(
        address _roleManager,
        address _timeLockActions
    ) external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        roleManager = MultiSigRoleManager(_roleManager);
        timeLockActions = TimeLockActions(_timeLockActions);
        
        emit SecurityContractsUpdated(_roleManager, _timeLockActions);
    }

    // ============ View Functions ============

    /**
     * @notice Get the required role for a proposal type
     * @param proposalType The proposal type
     * @return role The required role
     */
    function _getRequiredRoleForProposalType(ProposalType proposalType) internal pure returns (bytes32) {
        if (proposalType == ProposalType.Emergency) {
            return keccak256("SECURITY_COUNCIL_ROLE");
        }
        return keccak256("GOVERNANCE_ROLE");
    }

    /**
     * @notice Check if an address is a security council member
     * @param member Address to check
     * @return isMember True if the address is a security council member
     */
    function isSecurityCouncilMember(address member) external view returns (bool) {
        return securityCouncilMembers[member];
    }

    /**
     * @notice Get the current security contracts
     * @return _roleManager Address of the role manager
     * @return _timeLockActions Address of the time lock actions contract
     */
    function getSecurityContracts() external view returns (address _roleManager, address _timeLockActions) {
        return (address(roleManager), address(timeLockActions));
    }

    /**
     * @notice Get proposal type
     * @param proposalId The proposal ID
     * @return proposalType The proposal type
     */
    function getProposalType(uint256 proposalId) external view returns (ProposalType) {
        return proposalTypes[proposalId];
    }

    /**
     * @notice Check if a proposal is cancelled
     * @param proposalId The proposal ID
     * @return cancelled True if the proposal is cancelled
     */
    function isProposalCancelled(uint256 proposalId) external view returns (bool) {
        return proposalCancelled[proposalId];
    }

    /**
     * @notice Get the proposer of a proposal
     * @param proposalId The proposal ID
     * @return proposer The proposer address
     */
    function getProposalProposer(uint256 proposalId) external view returns (address) {
        return _proposalProposers[proposalId];
    }

    /**
     * @notice Get the number of security council members
     * @return count The number of security council members
     */
    function getSecurityCouncilMemberCount() external view returns (uint256) {
        return securityCouncilMemberCount;
    }

    // ============ Override Functions ============

    /**
     * @notice Get the voting delay
     * @return delay The voting delay in blocks
     */
    function votingDelay() public view override(IGovernor, GovernorSettingsUpgradeable) returns (uint256) {
        return super.votingDelay();
    }

    /**
     * @notice Get the voting period
     * @return period The voting period in blocks
     */
    function votingPeriod() public view override(IGovernor, GovernorSettingsUpgradeable) returns (uint256) {
        return super.votingPeriod();
    }

    /**
     * @notice Get the proposal threshold
     * @return threshold The proposal threshold
     */
    function proposalThreshold() public view override(GovernorUpgradeable, GovernorSettingsUpgradeable) returns (uint256) {
        return super.proposalThreshold();
    }

    /**
     * @notice Get the quorum
     * @param blockNumber The block number
     * @return quorum The quorum
     */
    function quorum(uint256 blockNumber) public view override(IGovernor, GovernorVotesQuorumFractionUpgradeable) returns (uint256) {
        return super.quorum(blockNumber);
    }

    /**
     * @notice Get the state of a proposal
     * @param proposalId The proposal ID
     * @return state The proposal state
     */
    function state(uint256 proposalId) public view override(IGovernor, GovernorTimelockControlUpgradeable) returns (ProposalState) {
        if (proposalCancelled[proposalId]) {
            return ProposalState.Canceled;
        }
        return super.state(proposalId);
    }
}
