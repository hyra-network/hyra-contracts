// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol";
import "../interfaces/IHyraToken.sol";
import "../security/MultiSigRoleManager.sol";
import "../security/TimeLockActions.sol";

/**
 * @title SecureHyraToken
 * @notice Secure ERC20 governance token with multi-signature role management
 * @dev This contract replaces the centralized owner role with multi-signature requirements
 *      All privileged operations now require multiple signatures and time delays
 */
contract SecureHyraToken is
    Initializable,
    ERC20Upgradeable,
    ERC20BurnableUpgradeable,
    ERC20PermitUpgradeable,
    ERC20VotesUpgradeable,
    OwnableUpgradeable,
    PausableUpgradeable,
    IHyraToken
{
    // ============ Constants ============
    uint256 public constant MAX_SUPPLY = 50_000_000_000e18; // 50 billion total cap
    
    // Minting tiers (annual caps)
    uint256 public constant TIER1_ANNUAL_CAP = 2_500_000_000e18; // 2.5B per year (5% of 50B)
    uint256 public constant TIER2_ANNUAL_CAP = 1_500_000_000e18; // 1.5B per year (3% of 50B)
    uint256 public constant TIER3_ANNUAL_CAP = 750_000_000e18;    // 750M per year (1.5% of 50B)
    
    // Time periods 
    uint256 public constant TIER1_END_YEAR = 10;  // Year 1-10
    uint256 public constant TIER2_END_YEAR = 15;  // Year 11-15
    uint256 public constant TIER3_END_YEAR = 25;  // Year 16-25
    uint256 public constant YEAR_DURATION = 365 days;
    
    // ============ State Variables ============
    mapping(address => bool) public minters;
    mapping(address => uint256) public mintAllowances;
    uint256 public totalMintedSupply;
    
    // Annual mint tracking
    uint256 public currentMintYear;
    uint256 public mintedThisYear;
    uint256 public mintYearStartTime;
    mapping(uint256 => uint256) public mintedByYear;
    uint256 public pendingMintAmount;
    
    // Security contracts
    MultiSigRoleManager public roleManager;
    TimeLockActions public timeLockActions;
    
    // Mint requests (must be approved by DAO)
    struct MintRequest {
        address recipient;
        uint256 amount;
        uint256 approvedAt;
        bool executed;
        string purpose;
    }
    
    mapping(uint256 => MintRequest) public mintRequests;
    uint256 public mintRequestCount;
    uint256 public constant MINT_EXECUTION_DELAY = 2 days;
    
    // Storage gap for upgradeability
    uint256[37] private __gap;

    // ============ Events ============
    event MinterAdded(address indexed minter);
    event MinterRemoved(address indexed minter);
    event MintAllowanceSet(address indexed minter, uint256 allowance);
    event GovernanceTransferred(address indexed oldGovernance, address indexed newGovernance);
    event MintRequestCreated(uint256 indexed requestId, address indexed recipient, uint256 amount, string purpose);
    event MintRequestExecuted(uint256 indexed requestId, address indexed recipient, uint256 amount);
    event MintRequestCancelled(uint256 indexed requestId);
    event MintYearReset(uint256 indexed newYear, uint256 timestamp);
    event SecurityContractsUpdated(address indexed roleManager, address indexed timeLockActions);

    // ============ Errors ============
    error ExceedsMaxSupply();
    error ExceedsAnnualCap();
    error MintDelayNotMet();
    error InvalidAddress();
    error InvalidAmount();
    error AlreadyMinter();
    error NotMinter();
    error InsufficientTokenBalance();
    error ZeroAddress();
    error InvalidSecurityContract();

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /**
     * @notice Initialize the Secure Token contract
     * @param name_ Name of the token
     * @param symbol_ Symbol of the token
     * @param _vestingContract Address of the vesting contract
     * @param _roleManager Address of the MultiSigRoleManager
     * @param _timeLockActions Address of the TimeLockActions contract
     */
    function initialize(
        string memory name_,
        string memory symbol_,
        address _vestingContract,
        address _roleManager,
        address _timeLockActions
    ) public initializer {
        __ERC20_init(name_, symbol_);
        __ERC20Burnable_init();
        __ERC20Permit_init(name_);
        __ERC20Votes_init();
        __Ownable_init();
        __Pausable_init();
        
        if (_roleManager == address(0) || _timeLockActions == address(0)) {
            revert ZeroAddress();
        }
        
        roleManager = MultiSigRoleManager(_roleManager);
        timeLockActions = TimeLockActions(_timeLockActions);
        
        // Initialize minting year
        currentMintYear = 1;
        mintYearStartTime = block.timestamp;
        
        // Mint initial supply to vesting contract
        if (_vestingContract != address(0)) {
            _mint(_vestingContract, 10_000_000_000e18); // 10B tokens to vesting
            totalMintedSupply += 10_000_000_000e18;
        }
        
        emit SecurityContractsUpdated(_roleManager, _timeLockActions);
    }

    /**
     * @notice Create a mint request (requires multi-signature)
     * @param _recipient Address to receive tokens
     * @param _amount Amount to mint
     * @param _purpose Purpose of the mint
     * @return requestId The request ID
     */
    function createMintRequest(
        address _recipient,
        uint256 _amount,
        string calldata _purpose
    ) external override returns (uint256) {
        if (_recipient == address(0)) revert InvalidAddress();
        if (_amount == 0) revert InvalidAmount();
        if (totalMintedSupply + _amount > MAX_SUPPLY) revert ExceedsMaxSupply();
        
        // Check annual mint cap
        _checkAndResetMintYear();
        if (mintedThisYear + _amount > _getAnnualMintCap()) revert ExceedsAnnualCap();
        
        uint256 requestId = mintRequestCount++;
        
        MintRequest storage request = mintRequests[requestId];
        request.recipient = _recipient;
        request.amount = _amount;
        request.purpose = _purpose;
        request.executed = false;
        
        pendingMintAmount += _amount;
        
        emit MintRequestCreated(requestId, _recipient, _amount, _purpose);
        
        return requestId;
    }

    /**
     * @notice Execute a mint request (requires multi-signature)
     * @param _requestId The request ID
     */
    function executeMintRequest(uint256 _requestId) external override {
        MintRequest storage request = mintRequests[_requestId];
        
        if (request.recipient == address(0)) revert InvalidAddress();
        if (request.executed) revert InvalidAmount();
        if (block.timestamp < request.approvedAt + MINT_EXECUTION_DELAY) revert MintDelayNotMet();
        
        // Execute through TimeLockActions
        bytes memory data = abi.encodeWithSelector(
            this._executeMintRequest.selector,
            _requestId
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.MINTER_ROLE(),
            0 // Use default delay
        );
    }

    /**
     * @notice Cancel a mint request (requires multi-signature)
     * @param _requestId The request ID
     */
    function cancelMintRequest(uint256 _requestId) external override {
        MintRequest storage request = mintRequests[_requestId];
        
        if (request.recipient == address(0)) revert InvalidAddress();
        if (request.executed) revert InvalidAmount();
        
        // Cancel through TimeLockActions
        bytes memory data = abi.encodeWithSelector(
            this._cancelMintRequest.selector,
            _requestId
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.MINTER_ROLE(),
            0 // Use default delay
        );
    }

    /**
     * @notice Add a minter (requires multi-signature)
     * @param _minter Address to grant minting permission
     */
    function addMinter(address _minter) external override {
        if (_minter == address(0)) revert InvalidAddress();
        
        // Add through TimeLockActions
        bytes memory data = abi.encodeWithSelector(
            this._addMinter.selector,
            _minter
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.MINTER_ROLE(),
            0 // Use default delay
        );
    }

    /**
     * @notice Remove a minter (requires multi-signature)
     * @param _minter Address to revoke minting permission
     */
    function removeMinter(address _minter) external override {
        // Remove through TimeLockActions
        bytes memory data = abi.encodeWithSelector(
            this._removeMinter.selector,
            _minter
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.MINTER_ROLE(),
            0 // Use default delay
        );
    }

    /**
     * @notice Set mint allowance (requires multi-signature)
     * @param _minter Address of the minter
     * @param _allowance Amount allowed to mint
     */
    function setMintAllowance(address _minter, uint256 _allowance) external override {
        // Set through TimeLockActions
        bytes memory data = abi.encodeWithSelector(
            this._setMintAllowance.selector,
            _minter,
            _allowance
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.MINTER_ROLE(),
            0 // Use default delay
        );
    }

    /**
     * @notice Transfer governance (requires multi-signature)
     * @param _newGovernance New governance address
     */
    function transferGovernance(address _newGovernance) external override {
        if (_newGovernance == address(0)) revert InvalidAddress();
        
        // Transfer through TimeLockActions
        bytes memory data = abi.encodeWithSelector(
            this._transferGovernance.selector,
            _newGovernance
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.GOVERNANCE_ROLE(),
            0 // Use default delay
        );
    }

    /**
     * @notice Pause token transfers (requires multi-signature)
     */
    function pause() external override {
        // Pause through TimeLockActions
        bytes memory data = abi.encodeWithSelector(
            this._pause.selector
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.PAUSER_ROLE(),
            0 // Use default delay
        );
    }

    /**
     * @notice Unpause token transfers (requires multi-signature)
     */
    function unpause() external override {
        // Unpause through TimeLockActions
        bytes memory data = abi.encodeWithSelector(
            this._unpause.selector
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.PAUSER_ROLE(),
            0 // Use default delay
        );
    }

    // ============ Internal Functions (called by TimeLockActions) ============

    /**
     * @notice Internal function to execute mint request (called by TimeLockActions)
     * @param _requestId The request ID
     */
    function _executeMintRequest(uint256 _requestId) external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        MintRequest storage request = mintRequests[_requestId];
        
        _mint(request.recipient, request.amount);
        totalMintedSupply += request.amount;
        mintedThisYear += request.amount;
        pendingMintAmount -= request.amount;
        request.executed = true;
        
        emit MintRequestExecuted(_requestId, request.recipient, request.amount);
    }

    /**
     * @notice Internal function to cancel mint request (called by TimeLockActions)
     * @param _requestId The request ID
     */
    function _cancelMintRequest(uint256 _requestId) external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        MintRequest storage request = mintRequests[_requestId];
        pendingMintAmount -= request.amount;
        
        emit MintRequestCancelled(_requestId);
    }

    /**
     * @notice Internal function to add minter (called by TimeLockActions)
     * @param _minter Address to grant minting permission
     */
    function _addMinter(address _minter) external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        if (minters[_minter]) revert AlreadyMinter();
        minters[_minter] = true;
        emit MinterAdded(_minter);
    }

    /**
     * @notice Internal function to remove minter (called by TimeLockActions)
     * @param _minter Address to revoke minting permission
     */
    function _removeMinter(address _minter) external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        if (!minters[_minter]) revert NotMinter();
        minters[_minter] = false;
        delete mintAllowances[_minter];
        emit MinterRemoved(_minter);
    }

    /**
     * @notice Internal function to set mint allowance (called by TimeLockActions)
     * @param _minter Address of the minter
     * @param _allowance Amount allowed to mint
     */
    function _setMintAllowance(address _minter, uint256 _allowance) external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        mintAllowances[_minter] = _allowance;
        emit MintAllowanceSet(_minter, _allowance);
    }

    /**
     * @notice Internal function to transfer governance (called by TimeLockActions)
     * @param _newGovernance New governance address
     */
    function _transferGovernance(address _newGovernance) external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        address oldGovernance = owner();
        _transferOwnership(_newGovernance);
        emit GovernanceTransferred(oldGovernance, _newGovernance);
    }

    /**
     * @notice Internal function to pause (called by TimeLockActions)
     */
    function _pause() external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        _pause();
    }

    /**
     * @notice Internal function to unpause (called by TimeLockActions)
     */
    function _unpause() external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        _unpause();
    }

    /**
     * @notice Update security contracts (requires multi-signature)
     * @param _roleManager New role manager address
     * @param _timeLockActions New time lock actions address
     */
    function updateSecurityContracts(
        address _roleManager,
        address _timeLockActions
    ) external {
        if (_roleManager == address(0) || _timeLockActions == address(0)) {
            revert ZeroAddress();
        }
        
        // This function requires multi-signature approval
        bytes memory data = abi.encodeWithSelector(
            this._updateSecurityContracts.selector,
            _roleManager,
            _timeLockActions
        );
        
        bytes32 actionHash = timeLockActions.scheduleAction(
            address(this),
            data,
            roleManager.GOVERNANCE_ROLE(),
            0 // Use default delay
        );
    }
    
    /**
     * @notice Internal function to update security contracts (called by TimeLockActions)
     * @param _roleManager New role manager address
     * @param _timeLockActions New time lock actions address
     */
    function _updateSecurityContracts(
        address _roleManager,
        address _timeLockActions
    ) external {
        // Only TimeLockActions can call this
        require(msg.sender == address(timeLockActions), "Only TimeLockActions");
        
        roleManager = MultiSigRoleManager(_roleManager);
        timeLockActions = TimeLockActions(_timeLockActions);
        
        emit SecurityContractsUpdated(_roleManager, _timeLockActions);
    }

    // ============ Internal Functions ============

    /**
     * @notice Check and reset mint year if necessary
     */
    function _checkAndResetMintYear() internal {
        if (block.timestamp >= mintYearStartTime + YEAR_DURATION) {
            // Calculate how many years have passed
            uint256 yearsPassed = (block.timestamp - mintYearStartTime) / YEAR_DURATION;
            
            currentMintYear += yearsPassed;
            mintYearStartTime += yearsPassed * YEAR_DURATION;
            mintedThisYear = 0; // Reset annual minted amount
            
            emit MintYearReset(currentMintYear, block.timestamp);
        }
    }

    /**
     * @notice Get annual mint cap for current year
     * @return cap Annual mint cap
     */
    function _getAnnualMintCap() internal view returns (uint256) {
        if (currentMintYear <= TIER1_END_YEAR) {
            return TIER1_ANNUAL_CAP;
        } else if (currentMintYear <= TIER2_END_YEAR) {
            return TIER2_ANNUAL_CAP;
        } else if (currentMintYear <= TIER3_END_YEAR) {
            return TIER3_ANNUAL_CAP;
        } else {
            return 0; // No more minting after year 25
        }
    }

    // ============ View Functions ============

    /**
     * @notice Get the current security contracts
     * @return _roleManager Address of the role manager
     * @return _timeLockActions Address of the time lock actions contract
     */
    function getSecurityContracts() external view returns (address _roleManager, address _timeLockActions) {
        return (address(roleManager), address(timeLockActions));
    }

    /**
     * @notice Get mint request details
     * @param _requestId The request ID
     * @return recipient Address to receive tokens
     * @return amount Amount to mint
     * @return approvedAt When the request was approved
     * @return executed Whether the request has been executed
     * @return purpose Purpose of the mint
     */
    function getMintRequest(uint256 _requestId) external view returns (
        address recipient,
        uint256 amount,
        uint256 approvedAt,
        bool executed,
        string memory purpose
    ) {
        MintRequest storage request = mintRequests[_requestId];
        return (
            request.recipient,
            request.amount,
            request.approvedAt,
            request.executed,
            request.purpose
        );
    }

    /**
     * @notice Get annual mint cap for a specific year
     * @param year The year
     * @return cap Annual mint cap
     */
    function getAnnualMintCap(uint256 year) external pure returns (uint256) {
        if (year <= TIER1_END_YEAR) {
            return TIER1_ANNUAL_CAP;
        } else if (year <= TIER2_END_YEAR) {
            return TIER2_ANNUAL_CAP;
        } else if (year <= TIER3_END_YEAR) {
            return TIER3_ANNUAL_CAP;
        } else {
            return 0;
        }
    }

    /**
     * @notice Check if an address is a minter
     * @param _minter Address to check
     * @return isMinter True if the address is a minter
     */
    function isMinter(address _minter) external view returns (bool) {
        return minters[_minter];
    }

    /**
     * @notice Get mint allowance for a minter
     * @param _minter Address of the minter
     * @return allowance Mint allowance
     */
    function getMintAllowance(address _minter) external view returns (uint256) {
        return mintAllowances[_minter];
    }

    /**
     * @notice Get pending mint amount
     * @return amount Pending mint amount
     */
    function getPendingMintAmount() external view returns (uint256) {
        return pendingMintAmount;
    }

    /**
     * @notice Get minted amount for a specific year
     * @param year The year
     * @return amount Minted amount
     */
    function getMintedByYear(uint256 year) external view returns (uint256) {
        return mintedByYear[year];
    }

    // ============ Override Functions ============

    /**
     * @notice Override transfer to respect pause
     * @param to Recipient address
     * @param amount Amount to transfer
     * @return success True if transfer successful
     */
    function transfer(address to, uint256 amount) public override(ERC20Upgradeable, IERC20) returns (bool) {
        return super.transfer(to, amount);
    }

    /**
     * @notice Override transferFrom to respect pause
     * @param from Sender address
     * @param to Recipient address
     * @param amount Amount to transfer
     * @return success True if transfer successful
     */
    function transferFrom(address from, address to, uint256 amount) public override(ERC20Upgradeable, IERC20) returns (bool) {
        return super.transferFrom(from, to, amount);
    }

    /**
     * @notice Override _update to respect pause
     * @param from Sender address
     * @param to Recipient address
     * @param value Amount to transfer
     */
    function _update(address from, address to, uint256 value) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {
        super._update(from, to, value);
    }
}
