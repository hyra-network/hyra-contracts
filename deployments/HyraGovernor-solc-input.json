{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorCountingSimple.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\n */\nabstract contract GovernorCountingSimpleUpgradeable is Initializable, GovernorUpgradeable {\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address voter => bool) hasVoted;\n    }\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorCountingSimple\n    struct GovernorCountingSimpleStorage {\n        mapping(uint256 proposalId => ProposalVote) _proposalVotes;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorCountingSimple\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorCountingSimpleStorageLocation = 0xa1cefa0f43667ef127a258e673c94202a79b656e62899531c4376d87a7f39800;\n\n    function _getGovernorCountingSimpleStorage() private pure returns (GovernorCountingSimpleStorage storage $) {\n        assembly {\n            $.slot := GovernorCountingSimpleStorageLocation\n        }\n    }\n\n    function __GovernorCountingSimple_init() internal onlyInitializing {\n    }\n\n    function __GovernorCountingSimple_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IGovernor\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /// @inheritdoc IGovernor\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        return $._proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }\n\n    /// @inheritdoc GovernorUpgradeable\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory // params\n    ) internal virtual override returns (uint256) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        if (proposalVote.hasVoted[account]) {\n            revert GovernorAlreadyCastVote(account);\n        }\n        proposalVote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalVote.againstVotes += totalWeight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalVote.forVotes += totalWeight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalVote.abstainVotes += totalWeight;\n        } else {\n            revert GovernorInvalidVoteType();\n        }\n\n        return totalWeight;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n */\nabstract contract GovernorSettingsUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorSettings\n    struct GovernorSettingsStorage {\n        // amount of token\n        uint256 _proposalThreshold;\n        // timepoint: limited to uint48 in core (same as clock() type)\n        uint48 _votingDelay;\n        // duration: limited to uint32 in core\n        uint32 _votingPeriod;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorSettings\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorSettingsStorageLocation = 0x00d7616c8fe29c6c2fbe1d0c5bc8f2faa4c35b43746e70b24b4d532752affd00;\n\n    function _getGovernorSettingsStorage() private pure returns (GovernorSettingsStorage storage $) {\n        assembly {\n            $.slot := GovernorSettingsStorageLocation\n        }\n    }\n\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    function __GovernorSettings_init(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);\n    }\n\n    function __GovernorSettings_init_unchained(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }\n\n    /// @inheritdoc IGovernor\n    function votingDelay() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._votingDelay;\n    }\n\n    /// @inheritdoc IGovernor\n    function votingPeriod() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._votingPeriod;\n    }\n\n    /// @inheritdoc GovernorUpgradeable\n    function proposalThreshold() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._proposalThreshold;\n    }\n\n    /**\n     * @dev Update the voting delay. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /**\n     * @dev Internal setter for the voting delay.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function _setVotingDelay(uint48 newVotingDelay) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        emit VotingDelaySet($._votingDelay, newVotingDelay);\n        $._votingDelay = newVotingDelay;\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint32 newVotingPeriod) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        if (newVotingPeriod == 0) {\n            revert GovernorInvalidVotingPeriod(0);\n        }\n        emit VotingPeriodSet($._votingPeriod, newVotingPeriod);\n        $._votingPeriod = newVotingPeriod;\n    }\n\n    /**\n     * @dev Internal setter for the proposal threshold.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        emit ProposalThresholdSet($._proposalThreshold, newProposalThreshold);\n        $._proposalThreshold = newProposalThreshold;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorTimelockControl.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {TimelockControllerUpgradeable} from \"../TimelockControllerUpgradeable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a\n * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The\n * {Governor} needs the proposer (and ideally the executor and canceller) roles for the {Governor} to work properly.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible from a proposal, unless executed via {Governor-relay}.\n *\n * WARNING: Setting up the TimelockController to have additional proposers or cancelers besides the governor is very\n * risky, as it grants them the ability to: 1) execute operations as the timelock, and thus possibly performing\n * operations or accessing funds that are expected to only be accessible through a vote, and 2) block governance\n * proposals that have been approved by the voters, effectively executing a Denial of Service attack.\n */\nabstract contract GovernorTimelockControlUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorTimelockControl\n    struct GovernorTimelockControlStorage {\n        TimelockControllerUpgradeable _timelock;\n        mapping(uint256 proposalId => bytes32) _timelockIds;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorTimelockControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorTimelockControlStorageLocation = 0x0d5829787b8befdbc6044ef7457d8a95c2a04bc99235349f1a212c063e59d400;\n\n    function _getGovernorTimelockControlStorage() private pure returns (GovernorTimelockControlStorage storage $) {\n        assembly {\n            $.slot := GovernorTimelockControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        __GovernorTimelockControl_init_unchained(timelockAddress);\n    }\n\n    function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-state} function that considers the status reported by the timelock.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        ProposalState currentState = super.state(proposalId);\n\n        if (currentState != ProposalState.Queued) {\n            return currentState;\n        }\n\n        bytes32 queueid = $._timelockIds[proposalId];\n        if ($._timelock.isOperationPending(queueid)) {\n            return ProposalState.Queued;\n        } else if ($._timelock.isOperationDone(queueid)) {\n            // This can happen if the proposal is executed directly on the timelock.\n            return ProposalState.Executed;\n        } else {\n            // This can happen if the proposal is canceled directly on the timelock.\n            return ProposalState.Canceled;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual returns (address) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        return address($._timelock);\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint48) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        uint256 delay = $._timelock.getMinDelay();\n\n        bytes32 salt = _timelockSalt(descriptionHash);\n        $._timelockIds[proposalId] = $._timelock.hashOperationBatch(targets, values, calldatas, 0, salt);\n        $._timelock.scheduleBatch(targets, values, calldatas, 0, salt, delay);\n\n        return SafeCast.toUint48(block.timestamp + delay);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_executeOperations} function that runs the already queued proposal\n     * through the timelock.\n     */\n    function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        // execute\n        $._timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, _timelockSalt(descriptionHash));\n        // cleanup for refund\n        delete $._timelockIds[proposalId];\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it has already\n     * been queued.\n     */\n    // This function can reenter through the external call to the timelock, but we assume the timelock is trusted and\n    // well behaved (according to TimelockController) and this will not happen.\n    // slither-disable-next-line reentrancy-no-eth\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        bytes32 timelockId = $._timelockIds[proposalId];\n        if (timelockId != 0) {\n            // cancel\n            $._timelock.cancel(timelockId);\n            // cleanup\n            delete $._timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        return address($._timelock);\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled, and executed through governance proposals.\n     *\n     * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.\n     */\n    function updateTimelock(TimelockControllerUpgradeable newTimelock) external virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        emit TimelockChange(address($._timelock), address(newTimelock));\n        $._timelock = newTimelock;\n    }\n\n    /**\n     * @dev Computes the {TimelockController} operation salt.\n     *\n     * It is computed with the governor address itself to avoid collisions across governor instances using the\n     * same timelock.\n     */\n    function _timelockSalt(bytes32 descriptionHash) private view returns (bytes32) {\n        return bytes20(address(this)) ^ descriptionHash;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorVotesUpgradeable} from \"./GovernorVotesUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a\n * fraction of the total supply.\n */\nabstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {\n    using Checkpoints for Checkpoints.Trace208;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotesQuorumFraction\n    struct GovernorVotesQuorumFractionStorage {\n        Checkpoints.Trace208 _quorumNumeratorHistory;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorVotesQuorumFraction\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorVotesQuorumFractionStorageLocation = 0xe770710421fd2cad75ad828c61aa98f2d77d423a440b67872d0f65554148e000;\n\n    function _getGovernorVotesQuorumFractionStorage() private pure returns (GovernorVotesQuorumFractionStorage storage $) {\n        assembly {\n            $.slot := GovernorVotesQuorumFractionStorageLocation\n        }\n    }\n\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n\n    /**\n     * @dev The quorum set is not a valid fraction.\n     */\n    error GovernorInvalidQuorumFraction(uint256 quorumNumerator, uint256 quorumDenominator);\n\n    /**\n     * @dev Initialize quorum as a fraction of the token's total supply.\n     *\n     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is\n     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be\n     * customized by overriding {quorumDenominator}.\n     */\n    function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {\n        __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);\n    }\n\n    function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current quorum numerator. See {quorumDenominator}.\n     */\n    function quorumNumerator() public view virtual returns (uint256) {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        return $._quorumNumeratorHistory.latest();\n    }\n\n    /**\n     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.\n     */\n    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        return _optimisticUpperLookupRecent($._quorumNumeratorHistory, timepoint);\n    }\n\n    /**\n     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.\n     */\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.\n     */\n    function quorum(uint256 timepoint) public view virtual override returns (uint256) {\n        return Math.mulDiv(token().getPastTotalSupply(timepoint), quorumNumerator(timepoint), quorumDenominator());\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        uint256 denominator = quorumDenominator();\n        if (newQuorumNumerator > denominator) {\n            revert GovernorInvalidQuorumFraction(newQuorumNumerator, denominator);\n        }\n\n        uint256 oldQuorumNumerator = quorumNumerator();\n        $._quorumNumeratorHistory.push(clock(), SafeCast.toUint208(newQuorumNumerator));\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n\n    /**\n     * @dev Returns the numerator at a specific timepoint.\n     */\n    function _optimisticUpperLookupRecent(\n        Checkpoints.Trace208 storage ckpts,\n        uint256 timepoint\n    ) internal view returns (uint256) {\n        // If trace is empty, key and value are both equal to 0.\n        // In that case `key <= timepoint` is true, and it is ok to return 0.\n        (, uint48 key, uint208 value) = ckpts.latestCheckpoint();\n        return key <= timepoint ? value : ckpts.upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport {IERC5805} from \"@openzeppelin/contracts/interfaces/IERC5805.sol\";\nimport {Time} from \"@openzeppelin/contracts/utils/types/Time.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes}\n * token.\n */\nabstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotes\n    struct GovernorVotesStorage {\n        IERC5805 _token;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorVotes\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorVotesStorageLocation = 0x3ba4977254e415696610a40ebf2258dbfa0ec6a2ff64e84bfe715ff16977cc00;\n\n    function _getGovernorVotesStorage() private pure returns (GovernorVotesStorage storage $) {\n        assembly {\n            $.slot := GovernorVotesStorageLocation\n        }\n    }\n\n    function __GovernorVotes_init(IVotes tokenAddress) internal onlyInitializing {\n        __GovernorVotes_init_unchained(tokenAddress);\n    }\n\n    function __GovernorVotes_init_unchained(IVotes tokenAddress) internal onlyInitializing {\n        GovernorVotesStorage storage $ = _getGovernorVotesStorage();\n        $._token = IERC5805(address(tokenAddress));\n    }\n\n    /**\n     * @dev The token that voting power is sourced from.\n     */\n    function token() public view virtual returns (IERC5805) {\n        GovernorVotesStorage storage $ = _getGovernorVotesStorage();\n        return $._token;\n    }\n\n    /**\n     * @dev Clock (as specified in ERC-6372) is set to match the token's clock. Fallback to block numbers if the token\n     * does not implement ERC-6372.\n     */\n    function clock() public view virtual override returns (uint48) {\n        try token().clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return Time.blockNumber();\n        }\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in ERC-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        try token().CLOCK_MODE() returns (string memory clockmode) {\n            return clockmode;\n        } catch {\n            return \"mode=blocknumber&from=default\";\n        }\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 timepoint,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token().getPastVotes(account, timepoint);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/Governor.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {EIP712Upgradeable} from \"../utils/cryptography/EIP712Upgradeable.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {DoubleEndedQueue} from \"@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {NoncesUpgradeable} from \"../utils/NoncesUpgradeable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended through various modules.\n *\n * This contract is abstract and requires several functions to be implemented in various modules:\n *\n * - A counting module must implement {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionally, {votingPeriod}, {votingDelay}, and {quorum} must also be implemented\n */\nabstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, NoncesUpgradeable, IGovernor, IERC721Receiver, IERC1155Receiver {\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n\n    bytes32 public constant BALLOT_TYPEHASH =\n        keccak256(\"Ballot(uint256 proposalId,uint8 support,address voter,uint256 nonce)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\n            \"ExtendedBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason,bytes params)\"\n        );\n\n    struct ProposalCore {\n        address proposer;\n        uint48 voteStart;\n        uint32 voteDuration;\n        bool executed;\n        bool canceled;\n        uint48 etaSeconds;\n    }\n\n    bytes32 private constant ALL_PROPOSAL_STATES_BITMAP = bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1);\n    /// @custom:storage-location erc7201:openzeppelin.storage.Governor\n    struct GovernorStorage {\n        string _name;\n\n        mapping(uint256 proposalId => ProposalCore) _proposals;\n\n        // This queue keeps track of the governor operating on itself. Calls to functions protected by the {onlyGovernance}\n        // modifier needs to be whitelisted in this queue. Whitelisting is set in {execute}, consumed by the\n        // {onlyGovernance} modifier and eventually reset after {_executeOperations} completes. This ensures that the\n        // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n        DoubleEndedQueue.Bytes32Deque _governanceCall;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Governor\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorStorageLocation = 0x7c712897014dbe49c045ef1299aa2d5f9e67e48eea4403efa21f1e0f3ac0cb00;\n\n    function _getGovernorStorage() private pure returns (GovernorStorage storage $) {\n        assembly {\n            $.slot := GovernorStorageLocation\n        }\n    }\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        _checkGovernance();\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    function __Governor_init(string memory name_) internal onlyInitializing {\n        __EIP712_init_unchained(name_, version());\n        __Governor_init_unchained(name_);\n    }\n\n    function __Governor_init_unchained(string memory name_) internal onlyInitializing {\n        GovernorStorage storage $ = _getGovernorStorage();\n        $._name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IGovernor).interfaceId ||\n            interfaceId == type(IGovernor).interfaceId ^ IGovernor.getProposalId.selector ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IGovernor\n    function name() public view virtual returns (string memory) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._name;\n    }\n\n    /// @inheritdoc IGovernor\n    function version() public view virtual returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /// @inheritdoc IGovernor\n    function getProposalId(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public view virtual returns (uint256) {\n        return hashProposal(targets, values, calldatas, descriptionHash);\n    }\n\n    /// @inheritdoc IGovernor\n    function state(uint256 proposalId) public view virtual returns (ProposalState) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        // We read the struct fields into the stack at once so Solidity emits a single SLOAD\n        ProposalCore storage proposal = $._proposals[proposalId];\n        bool proposalExecuted = proposal.executed;\n        bool proposalCanceled = proposal.canceled;\n\n        if (proposalExecuted) {\n            return ProposalState.Executed;\n        }\n\n        if (proposalCanceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        } else if (!_quorumReached(proposalId) || !_voteSucceeded(proposalId)) {\n            return ProposalState.Defeated;\n        } else if (proposalEta(proposalId) == 0) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].voteStart;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].voteStart + $._proposals[proposalId].voteDuration;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalProposer(uint256 proposalId) public view virtual returns (address) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].proposer;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].etaSeconds;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalNeedsQueuing(uint256) public view virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev Reverts if the `msg.sender` is not the executor. In case the executor is not this contract\n     * itself, the function reverts if `msg.data` is not whitelisted as a result of an {execute}\n     * operation. See {onlyGovernance}.\n     */\n    function _checkGovernance() internal virtual {\n        GovernorStorage storage $ = _getGovernorStorage();\n        if (_executor() != _msgSender()) {\n            revert GovernorOnlyExecutor(_msgSender());\n        }\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while ($._governanceCall.popFront() != msgDataHash) {}\n        }\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory params\n    ) internal virtual returns (uint256);\n\n    /**\n     * @dev Hook that should be called every time the tally for a proposal is updated.\n     *\n     * Note: This function must run successfully. Reverts will result in the bricking of governance\n     */\n    function _tallyUpdated(uint256 proposalId) internal virtual {}\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256) {\n        address proposer = _msgSender();\n\n        // check description restriction\n        if (!_isValidDescriptionForProposer(proposer, description)) {\n            revert GovernorRestrictedProposer(proposer);\n        }\n\n        // check proposal threshold\n        uint256 votesThreshold = proposalThreshold();\n        if (votesThreshold > 0) {\n            uint256 proposerVotes = getVotes(proposer, clock() - 1);\n            if (proposerVotes < votesThreshold) {\n                revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);\n            }\n        }\n\n        return _propose(targets, values, calldatas, description, proposer);\n    }\n\n    /**\n     * @dev Internal propose mechanism. Can be overridden to add more logic on proposal creation.\n     *\n     * Emits a {IGovernor-ProposalCreated} event.\n     */\n    function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual returns (uint256 proposalId) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        proposalId = getProposalId(targets, values, calldatas, keccak256(bytes(description)));\n\n        if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) {\n            revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length);\n        }\n        if ($._proposals[proposalId].voteStart != 0) {\n            revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0));\n        }\n\n        uint256 snapshot = clock() + votingDelay();\n        uint256 duration = votingPeriod();\n\n        ProposalCore storage proposal = $._proposals[proposalId];\n        proposal.proposer = proposer;\n        proposal.voteStart = SafeCast.toUint48(snapshot);\n        proposal.voteDuration = SafeCast.toUint32(duration);\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            snapshot + duration,\n            description\n        );\n\n        // Using a named return variable to avoid stack too deep errors\n    }\n\n    /// @inheritdoc IGovernor\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Succeeded));\n\n        uint48 etaSeconds = _queueOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        if (etaSeconds != 0) {\n            $._proposals[proposalId].etaSeconds = etaSeconds;\n            emit ProposalQueued(proposalId, etaSeconds);\n        } else {\n            revert GovernorQueueNotImplemented();\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal queuing mechanism. Can be overridden (without a super call) to modify the way queuing is\n     * performed (for example adding a vault/timelock).\n     *\n     * This is empty by default, and must be overridden to implement queuing.\n     *\n     * This function returns a timestamp that describes the expected ETA for execution. If the returned value is 0\n     * (which is the default value), the core will consider queueing did not succeed, and the public {queue} function\n     * will revert.\n     *\n     * NOTE: Calling this function directly will NOT check the current state of the proposal, or emit the\n     * `ProposalQueued` event. Queuing a proposal should be done using {queue}.\n     */\n    function _queueOperations(\n        uint256 /*proposalId*/,\n        address[] memory /*targets*/,\n        uint256[] memory /*values*/,\n        bytes[] memory /*calldatas*/,\n        bytes32 /*descriptionHash*/\n    ) internal virtual returns (uint48) {\n        return 0;\n    }\n\n    /// @inheritdoc IGovernor\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued)\n        );\n\n        // mark as executed before calls to avoid reentrancy\n        $._proposals[proposalId].executed = true;\n\n        // before execute: register governance call in queue.\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    $._governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n\n        _executeOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        // after execute: cleanup governance call queue.\n        if (_executor() != address(this) && !$._governanceCall.empty()) {\n            $._governanceCall.clear();\n        }\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden (without a super call) to modify the way execution is\n     * performed (for example adding a vault/timelock).\n     *\n     * NOTE: Calling this function directly will NOT check the current state of the proposal, set the executed flag to\n     * true or emit the `ProposalExecuted` event. Executing a proposal should be done using {execute}.\n     */\n    function _executeOperations(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            Address.verifyCallResult(success, returndata);\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        // The proposalId will be recomputed in the `_cancel` call further down. However we need the value before we\n        // do the internal call, because we need to check the proposal state BEFORE the internal `_cancel` call\n        // changes it. The `getProposalId` duplication has a cost that is limited, and that we accept.\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        address caller = _msgSender();\n        if (!_validateCancel(proposalId, caller)) revert GovernorUnableToCancel(proposalId, caller);\n\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Internal cancel mechanism with minimal restrictions. A proposal can be cancelled in any state other than\n     * Canceled, Expired, or Executed. Once cancelled a proposal can't be re-submitted.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            ALL_PROPOSAL_STATES_BITMAP ^\n                _encodeStateBitmap(ProposalState.Canceled) ^\n                _encodeStateBitmap(ProposalState.Expired) ^\n                _encodeStateBitmap(ProposalState.Executed)\n        );\n\n        $._proposals[proposalId].canceled = true;\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /// @inheritdoc IGovernor\n    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        return _getVotes(account, timepoint, _defaultParams());\n    }\n\n    /// @inheritdoc IGovernor\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual returns (uint256) {\n        return _getVotes(account, timepoint, params);\n    }\n\n    /// @inheritdoc IGovernor\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) public virtual returns (uint256) {\n        if (!_validateVoteSig(proposalId, support, voter, signature)) {\n            revert GovernorInvalidSignature(voter);\n        }\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string calldata reason,\n        bytes memory params,\n        bytes memory signature\n    ) public virtual returns (uint256) {\n        if (!_validateExtendedVoteSig(proposalId, support, voter, reason, params, signature)) {\n            revert GovernorInvalidSignature(voter);\n        }\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /// @dev Validate the `signature` used in {castVoteBySig} function.\n    function _validateVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) internal virtual returns (bool) {\n        return\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter)))),\n                signature\n            );\n    }\n\n    /// @dev Validate the `signature` used in {castVoteWithReasonAndParamsBySig} function.\n    function _validateExtendedVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string memory reason,\n        bytes memory params,\n        bytes memory signature\n    ) internal virtual returns (bool) {\n        return\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(\n                    keccak256(\n                        abi.encode(\n                            EXTENDED_BALLOT_TYPEHASH,\n                            proposalId,\n                            support,\n                            voter,\n                            _useNonce(voter),\n                            keccak256(bytes(reason)),\n                            keccak256(params)\n                        )\n                    )\n                ),\n                signature\n            );\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return _castVote(proposalId, account, support, reason, _defaultParams());\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active));\n\n        uint256 totalWeight = _getVotes(account, proposalSnapshot(proposalId), params);\n        uint256 votedWeight = _countVote(proposalId, account, support, totalWeight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, votedWeight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, votedWeight, reason, params);\n        }\n\n        _tallyUpdated(proposalId);\n\n        return votedWeight;\n    }\n\n    /**\n     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor\n     * is some contract other than the governor itself, like when using a timelock, this function can be invoked\n     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.\n     * Note that if the executor is simply the governor itself, use of `relay` is redundant.\n     */\n    function relay(address target, uint256 value, bytes calldata data) external payable virtual onlyGovernance {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        Address.verifyCallResult(success, returndata);\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev Encodes a `ProposalState` into a `bytes32` representation where each bit enabled corresponds to\n     * the underlying position in the `ProposalState` enum. For example:\n     *\n     * 0x000...10000\n     *   ^^^^^^------ ...\n     *         ^----- Succeeded\n     *          ^---- Defeated\n     *           ^--- Canceled\n     *            ^-- Active\n     *             ^- Pending\n     */\n    function _encodeStateBitmap(ProposalState proposalState) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(proposalState));\n    }\n\n    /**\n     * @dev Check that the current state of a proposal matches the requirements described by the `allowedStates` bitmap.\n     * This bitmap should be built using `_encodeStateBitmap`.\n     *\n     * If requirements are not met, reverts with a {GovernorUnexpectedProposalState} error.\n     */\n    function _validateStateBitmap(uint256 proposalId, bytes32 allowedStates) internal view returns (ProposalState) {\n        ProposalState currentState = state(proposalId);\n        if (_encodeStateBitmap(currentState) & allowedStates == bytes32(0)) {\n            revert GovernorUnexpectedProposalState(proposalId, currentState, allowedStates);\n        }\n        return currentState;\n    }\n\n    /*\n     * @dev Check if the proposer is authorized to submit a proposal with the given description.\n     *\n     * If the proposal description ends with `#proposer=0x???`, where `0x???` is an address written as a hex string\n     * (case insensitive), then the submission of this proposal will only be authorized to said address.\n     *\n     * This is used for frontrunning protection. By adding this pattern at the end of their proposal, one can ensure\n     * that no other address can submit the same proposal. An attacker would have to either remove or change that part,\n     * which would result in a different proposal id.\n     *\n     * If the description does not match this pattern, it is unrestricted and anyone can submit it. This includes:\n     * - If the `0x???` part is not a valid hex string.\n     * - If the `0x???` part is a valid hex string, but does not contain exactly 40 hex digits.\n     * - If it ends with the expected suffix followed by newlines or other whitespace.\n     * - If it ends with some other similar suffix, e.g. `#other=abc`.\n     * - If it does not end with any such suffix.\n     */\n    function _isValidDescriptionForProposer(\n        address proposer,\n        string memory description\n    ) internal view virtual returns (bool) {\n        unchecked {\n            uint256 length = bytes(description).length;\n\n            // Length is too short to contain a valid proposer suffix\n            if (length < 52) {\n                return true;\n            }\n\n            // Extract what would be the `#proposer=` marker beginning the suffix\n            bytes10 marker = bytes10(_unsafeReadBytesOffset(bytes(description), length - 52));\n\n            // If the marker is not found, there is no proposer suffix to check\n            if (marker != bytes10(\"#proposer=\")) {\n                return true;\n            }\n\n            // Check that the last 42 characters (after the marker) are a properly formatted address.\n            (bool success, address recovered) = Strings.tryParseAddress(description, length - 42, length);\n            return !success || recovered == proposer;\n        }\n    }\n\n    /**\n     * @dev Check if the `caller` can cancel the proposal with the given `proposalId`.\n     *\n     * The default implementation allows the proposal proposer to cancel the proposal during the pending state.\n     */\n    function _validateCancel(uint256 proposalId, address caller) internal view virtual returns (bool) {\n        return (state(proposalId) == ProposalState.Pending) && caller == proposalProposer(proposalId);\n    }\n\n    /// @inheritdoc IERC6372\n    function clock() public view virtual returns (uint48);\n\n    /// @inheritdoc IERC6372\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory);\n\n    /// @inheritdoc IGovernor\n    function votingDelay() public view virtual returns (uint256);\n\n    /// @inheritdoc IGovernor\n    function votingPeriod() public view virtual returns (uint256);\n\n    /// @inheritdoc IGovernor\n    function quorum(uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.20;\n\nimport {AccessControlUpgradeable} from \"../access/AccessControlUpgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"../token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {ERC1155HolderUpgradeable} from \"../token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n */\ncontract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.TimelockController\n    struct TimelockControllerStorage {\n        mapping(bytes32 id => uint256) _timestamps;\n        uint256 _minDelay;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.TimelockController\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant TimelockControllerStorageLocation = 0x9a37c2aa9d186a0969ff8a8267bf4e07e864c2f2768f5040949e28a624fb3600;\n\n    function _getTimelockControllerStorage() private pure returns (TimelockControllerStorage storage $) {\n        assembly {\n            $.slot := TimelockControllerStorageLocation\n        }\n    }\n\n    enum OperationState {\n        Unset,\n        Waiting,\n        Ready,\n        Done\n    }\n\n    /**\n     * @dev Mismatch between the parameters length for an operation call.\n     */\n    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);\n\n    /**\n     * @dev The schedule operation doesn't meet the minimum delay.\n     */\n    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);\n\n    /**\n     * @dev The current state of an operation is not as required.\n     * The `expectedStates` is a bitmap with the bits enabled for each OperationState enum position\n     * counting from right to left.\n     *\n     * See {_encodeStateBitmap}.\n     */\n    error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates);\n\n    /**\n     * @dev The predecessor to an operation not yet done.\n     */\n    error TimelockUnexecutedPredecessor(bytes32 predecessorId);\n\n    /**\n     * @dev The caller account is not authorized.\n     */\n    error TimelockUnauthorizedCaller(address caller);\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\n     */\n    event CallSalt(bytes32 indexed id, bytes32 salt);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) public virtual initializer {\n        __TimelockController_init(minDelay, proposers, executors, admin);\n    }\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay in seconds for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        __TimelockController_init_unchained(minDelay, proposers, executors, admin);\n    }\n\n    function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        // self administration\n        _grantRole(DEFAULT_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _grantRole(PROPOSER_ROLE, proposers[i]);\n            _grantRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _grantRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        $._minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable virtual {}\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlUpgradeable, ERC1155HolderUpgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id corresponds to a registered operation. This\n     * includes both Waiting, Ready, and Done operations.\n     */\n    function isOperation(bytes32 id) public view returns (bool) {\n        return getOperationState(id) != OperationState.Unset;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n     */\n    function isOperationPending(bytes32 id) public view returns (bool) {\n        OperationState state = getOperationState(id);\n        return state == OperationState.Waiting || state == OperationState.Ready;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n     */\n    function isOperationReady(bytes32 id) public view returns (bool) {\n        return getOperationState(id) == OperationState.Ready;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view returns (bool) {\n        return getOperationState(id) == OperationState.Done;\n    }\n\n    /**\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        return $._timestamps[id];\n    }\n\n    /**\n     * @dev Returns operation state.\n     */\n    function getOperationState(bytes32 id) public view virtual returns (OperationState) {\n        uint256 timestamp = getTimestamp(id);\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == _DONE_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }\n\n    /**\n     * @dev Returns the minimum delay in seconds for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        return $._minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        if (targets.length != values.length || targets.length != payloads.length) {\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to become valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (isOperation(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));\n        }\n        uint256 minDelay = getMinDelay();\n        if (delay < minDelay) {\n            revert TimelockInsufficientDelay(delay, minDelay);\n        }\n        $._timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (!isOperationPending(id)) {\n            revert TimelockUnexpectedOperationState(\n                id,\n                _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)\n            );\n        }\n        delete $._timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        if (targets.length != values.length || targets.length != payloads.length) {\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        Address.verifyCallResult(success, returndata);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        if (!isOperationReady(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\n        }\n        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {\n            revert TimelockUnexecutedPredecessor(predecessor);\n        }\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (!isOperationReady(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\n        }\n        $._timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        address sender = _msgSender();\n        if (sender != address(this)) {\n            revert TimelockUnauthorizedCaller(sender);\n        }\n        emit MinDelayChange($._minDelay, newDelay);\n        $._minDelay = newDelay;\n    }\n\n    /**\n     * @dev Encodes a `OperationState` into a `bytes32` representation where each bit enabled corresponds to\n     * the underlying position in the `OperationState` enum. For example:\n     *\n     * 0x000...1000\n     *   ^^^^^^----- ...\n     *         ^---- Done\n     *          ^--- Ready\n     *           ^-- Waiting\n     *            ^- Unset\n     */\n    function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(operationState));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/utils/VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (governance/utils/Votes.sol)\npragma solidity ^0.8.20;\n\nimport {IERC5805} from \"@openzeppelin/contracts/interfaces/IERC5805.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {NoncesUpgradeable} from \"../../utils/NoncesUpgradeable.sol\";\nimport {EIP712Upgradeable} from \"../../utils/cryptography/EIP712Upgradeable.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Time} from \"@openzeppelin/contracts/utils/types/Time.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_update}).\n */\nabstract contract VotesUpgradeable is Initializable, ContextUpgradeable, EIP712Upgradeable, NoncesUpgradeable, IERC5805 {\n    using Checkpoints for Checkpoints.Trace208;\n\n    bytes32 private constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Votes\n    struct VotesStorage {\n        mapping(address account => address) _delegatee;\n\n        mapping(address delegatee => Checkpoints.Trace208) _delegateCheckpoints;\n\n        Checkpoints.Trace208 _totalCheckpoints;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Votes\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant VotesStorageLocation = 0xe8b26c30fad74198956032a3533d903385d56dd795af560196f9c78d4af40d00;\n\n    function _getVotesStorage() private pure returns (VotesStorage storage $) {\n        assembly {\n            $.slot := VotesStorageLocation\n        }\n    }\n\n    /**\n     * @dev The clock was incorrectly modified.\n     */\n    error ERC6372InconsistentClock();\n\n    /**\n     * @dev Lookup to future votes is not available.\n     */\n    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);\n\n    function __Votes_init() internal onlyInitializing {\n    }\n\n    function __Votes_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n     */\n    function clock() public view virtual returns (uint48) {\n        return Time.blockNumber();\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in ERC-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory) {\n        // Check that the clock was not modified\n        if (clock() != Time.blockNumber()) {\n            revert ERC6372InconsistentClock();\n        }\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Validate that a timepoint is in the past, and return it as a uint48.\n     */\n    function _validateTimepoint(uint256 timepoint) internal view returns (uint48) {\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        return SafeCast.toUint48(timepoint);\n    }\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint));\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._totalCheckpoints.upperLookupRecent(_validateTimepoint(timepoint));\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._totalCheckpoints.latest();\n    }\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegatee[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > expiry) {\n            revert VotesExpiredSignature(expiry);\n        }\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        _useCheckedNonce(signer, nonce);\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        address oldDelegate = delegates(account);\n        $._delegatee[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from == address(0)) {\n            _push($._totalCheckpoints, _add, SafeCast.toUint208(amount));\n        }\n        if (to == address(0)) {\n            _push($._totalCheckpoints, _subtract, SafeCast.toUint208(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(address from, address to, uint256 amount) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[from],\n                    _subtract,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[to],\n                    _add,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function _numCheckpoints(address account) internal view virtual returns (uint32) {\n        VotesStorage storage $ = _getVotesStorage();\n        return SafeCast.toUint32($._delegateCheckpoints[account].length());\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function _checkpoints(\n        address account,\n        uint32 pos\n    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].at(pos);\n    }\n\n    function _push(\n        Checkpoints.Trace208 storage store,\n        function(uint208, uint208) view returns (uint208) op,\n        uint208 delta\n    ) private returns (uint208 oldValue, uint208 newValue) {\n        return store.push(clock(), op(store.latest(), delta));\n    }\n\n    function _add(uint208 a, uint208 b) private pure returns (uint208) {\n        return a + b;\n    }\n\n    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {\n        return a - b;\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n */\nabstract contract ERC1155HolderUpgradeable is Initializable, ERC165Upgradeable, IERC1155Receiver {\n    function __ERC1155Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {ContextUpgradeable} from \"../../../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712Upgradeable} from \"../../../utils/cryptography/EIP712Upgradeable.sol\";\nimport {NoncesUpgradeable} from \"../../../utils/NoncesUpgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable, NoncesUpgradeable {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC-20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /// @inheritdoc IERC20Permit\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /// @inheritdoc IERC20Permit\n    function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /// @inheritdoc IERC20Permit\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {VotesUpgradeable} from \"../../../governance/utils/VotesUpgradeable.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC-20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: This contract does not provide interface compatibility with Compound's COMP token.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {Votes-delegate} function directly, or by providing a signature to be used with {Votes-delegateBySig}. Voting\n * power can be queried through the public accessors {Votes-getVotes} and {Votes-getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20Upgradeable, VotesUpgradeable {\n    /**\n     * @dev Total supply cap has been exceeded, introducing a risk of votes overflowing.\n     */\n    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);\n\n    function __ERC20Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint208).max` (2^208^ - 1).\n     *\n     * This maximum is enforced in {_update}. It limits the total supply of the token, which is otherwise a uint256,\n     * so that checkpoints can be stored in the Trace208 structure used by {Votes}. Increasing this value will not\n     * remove the underlying limitation, and will cause {_update} to fail because of a math overflow in\n     * {Votes-_transferVotingUnits}. An override could be used to further restrict the total supply (to a lower value) if\n     * additional logic requires it. When resolving override conflicts on this function, the minimum should be\n     * returned.\n     */\n    function _maxSupply() internal view virtual returns (uint256) {\n        return type(uint208).max;\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override {\n        super._update(from, to, value);\n        if (from == address(0)) {\n            uint256 supply = totalSupply();\n            uint256 cap = _maxSupply();\n            if (supply > cap) {\n                revert ERC20ExceededSafeSupply(supply, cap);\n            }\n        }\n        _transferVotingUnits(from, to, value);\n    }\n\n    /**\n     * @dev Returns the voting units of an `account`.\n     *\n     * WARNING: Overriding this function may compromise the internal vote accounting.\n     * `ERC20Votes` assumes tokens map to voting units 1:1 and this is not easy to change.\n     */\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return _numCheckpoints(account);\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {\n        return _checkpoints(account, pos);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\n * {IERC721-setApprovalForAll}.\n */\nabstract contract ERC721HolderUpgradeable is Initializable, IERC721Receiver {\n    function __ERC721Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: The upgradeable version of this contract does not use an immutable cache and recomputes the domain separator\n * each time {_domainSeparatorV4} is called. That is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /// @inheritdoc IERC5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract NoncesUpgradeable is Initializable {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces\n    struct NoncesStorage {\n        mapping(address account => uint256) _nonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Nonces\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;\n\n    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\n        assembly {\n            $.slot := NoncesStorageLocation\n        }\n    }\n\n    function __Nonces_init() internal onlyInitializing {\n    }\n\n    function __Nonces_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        return $._nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return $._nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    function __Pausable_init() internal onlyInitializing {\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/IGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/IGovernor.sol)\n\npragma solidity >=0.8.4;\n\nimport {IERC165} from \"../interfaces/IERC165.sol\";\nimport {IERC6372} from \"../interfaces/IERC6372.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * NOTE: Event parameters lack the `indexed` keyword for compatibility with GovernorBravo events.\n * Making event parameters `indexed` affects how events are decoded, potentially breaking existing indexers.\n */\ninterface IGovernor is IERC165, IERC6372 {\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Empty proposal or a mismatch between the parameters length for a proposal call.\n     */\n    error GovernorInvalidProposalLength(uint256 targets, uint256 calldatas, uint256 values);\n\n    /**\n     * @dev The vote was already cast.\n     */\n    error GovernorAlreadyCastVote(address voter);\n\n    /**\n     * @dev Token deposits are disabled in this contract.\n     */\n    error GovernorDisabledDeposit();\n\n    /**\n     * @dev The `account` is not the governance executor.\n     */\n    error GovernorOnlyExecutor(address account);\n\n    /**\n     * @dev The `proposalId` doesn't exist.\n     */\n    error GovernorNonexistentProposal(uint256 proposalId);\n\n    /**\n     * @dev The current state of a proposal is not the required for performing an operation.\n     * The `expectedStates` is a bitmap with the bits enabled for each ProposalState enum position\n     * counting from right to left.\n     *\n     * NOTE: If `expectedState` is `bytes32(0)`, the proposal is expected to not be in any state (i.e. not exist).\n     * This is the case when a proposal that is expected to be unset is already initiated (the proposal is duplicated).\n     *\n     * See {Governor-_encodeStateBitmap}.\n     */\n    error GovernorUnexpectedProposalState(uint256 proposalId, ProposalState current, bytes32 expectedStates);\n\n    /**\n     * @dev The voting period set is not a valid period.\n     */\n    error GovernorInvalidVotingPeriod(uint256 votingPeriod);\n\n    /**\n     * @dev The `proposer` does not have the required votes to create a proposal.\n     */\n    error GovernorInsufficientProposerVotes(address proposer, uint256 votes, uint256 threshold);\n\n    /**\n     * @dev The `proposer` is not allowed to create a proposal.\n     */\n    error GovernorRestrictedProposer(address proposer);\n\n    /**\n     * @dev The vote type used is not valid for the corresponding counting module.\n     */\n    error GovernorInvalidVoteType();\n\n    /**\n     * @dev The provided params buffer is not supported by the counting module.\n     */\n    error GovernorInvalidVoteParams();\n\n    /**\n     * @dev Queue operation is not implemented for this governor. Execute should be called directly.\n     */\n    error GovernorQueueNotImplemented();\n\n    /**\n     * @dev The proposal hasn't been queued yet.\n     */\n    error GovernorNotQueuedProposal(uint256 proposalId);\n\n    /**\n     * @dev The proposal has already been queued.\n     */\n    error GovernorAlreadyQueuedProposal(uint256 proposalId);\n\n    /**\n     * @dev The provided signature is not valid for the expected `voter`.\n     * If the `voter` is a contract, the signature is not valid using {IERC1271-isValidSignature}.\n     */\n    error GovernorInvalidSignature(address voter);\n\n    /**\n     * @dev The given `account` is unable to cancel the proposal with given `proposalId`.\n     */\n    error GovernorUnableToCancel(uint256 proposalId, address account);\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is queued.\n     */\n    event ProposalQueued(uint256 proposalId, uint256 etaSeconds);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast without params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @dev Emitted when a vote is cast with params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     * `params` are additional encoded parameters. Their interpretation  also depends on the voting module used.\n     */\n    event VoteCastWithParams(\n        address indexed voter,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason,\n        bytes params\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the EIP-712 domain separator).\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the EIP-712 domain separator). Default: \"1\"\n     */\n    function version() external view returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() external view returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details.\n     *\n     * NOTE: For all off-chain and external calls, use {getProposalId}.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external pure returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Function used to get the proposal id from the proposal details.\n     */\n    function getProposalId(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) external view returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev The number of votes required in order for a voter to become a proposer.\n     */\n    function proposalThreshold() external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the\n     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the\n     * following block.\n     */\n    function proposalSnapshot(uint256 proposalId) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is\n     * possible to cast a vote during this block.\n     */\n    function proposalDeadline(uint256 proposalId) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev The account that created a proposal.\n     */\n    function proposalProposer(uint256 proposalId) external view returns (address);\n\n    /**\n     * @notice module:core\n     * @dev The time when a queued proposal becomes executable (\"ETA\"). Unlike {proposalSnapshot} and\n     * {proposalDeadline}, this doesn't use the governor clock, and instead relies on the executor's clock which may be\n     * different. In most cases this will be a timestamp.\n     */\n    function proposalEta(uint256 proposalId) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Whether a proposal needs to be queued before execution.\n     */\n    function proposalNeedsQueuing(uint256 proposalId) external view returns (bool);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends\n     * on the clock (see ERC-6372) this contract uses.\n     *\n     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a\n     * proposal starts.\n     *\n     * NOTE: While this interface returns a uint256, timepoints are stored as uint48 following the ERC-6372 clock type.\n     * Consequently this value must fit in a uint48 (when added to the current clock). See {IERC6372-clock}.\n     */\n    function votingDelay() external view returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock\n     * (see ERC-6372) this contract uses.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     *\n     * NOTE: This value is stored when the proposal is submitted so that possible changes to the value do not affect\n     * proposals that have already been submitted. The type used to save it is a uint32. Consequently, while this\n     * interface returns a uint256, the value it returns should fit in a uint32.\n     */\n    function votingPeriod() external view returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).\n     */\n    function quorum(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) external view returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns whether `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) external view returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a\n     * duration specified by {IGovernor-votingPeriod}.\n     *\n     * Emits a {ProposalCreated} event.\n     *\n     * NOTE: The state of the Governor and `targets` may change between the proposal creation and its execution.\n     * This may be the result of third party actions on the targeted contracts, or other governor proposals.\n     * For example, the balance of this contract could be updated or its access control permissions may be modified,\n     * possibly compromising the proposal's ability to execute successfully (e.g. the governor doesn't have enough\n     * value to cover a proposal with multiple transfers).\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256 proposalId);\n\n    /**\n     * @dev Queue a proposal. Some governors require this step to be performed before execution can happen. If queuing\n     * is not necessary, this function may revert.\n     * Queuing a proposal requires the quorum to be reached, the vote to be successful, and the deadline to be reached.\n     *\n     * Emits a {ProposalQueued} event.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached. Depending on the governor it might also be required that the proposal was queued and\n     * that some delay passed.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * NOTE: Some modules can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external payable returns (uint256 proposalId);\n\n    /**\n     * @dev Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e.\n     * before the vote starts.\n     *\n     * Emits a {ProposalCanceled} event.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the voter's signature, including ERC-1271 signature support.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters using the voter's signature,\n     * including ERC-1271 signature support.\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string calldata reason,\n        bytes memory params,\n        bytes memory signature\n    ) external returns (uint256 balance);\n}\n"
    },
    "@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/utils/IVotes.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n */\ninterface IVotes {\n    /**\n     * @dev The signature used has expired.\n     */\n    error VotesExpiredSignature(uint256 expiry);\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of voting units.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1271.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the ERC-1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with `hash`\n     */\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1967.sol)\n\npragma solidity >=0.4.11;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC5267.sol)\n\npragma solidity >=0.4.16;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5805.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC5805.sol)\n\npragma solidity >=0.8.4;\n\nimport {IVotes} from \"../governance/utils/IVotes.sol\";\nimport {IERC6372} from \"./IERC6372.sol\";\n\ninterface IERC5805 is IERC6372, IVotes {}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC6372.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC6372.sol)\n\npragma solidity >=0.4.16;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC7913.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC7913.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @dev Signature verifier interface.\n */\ninterface IERC7913SignatureVerifier {\n    /**\n     * @dev Verifies `signature` as a valid signature of `hash` by `key`.\n     *\n     * MUST return the bytes4 magic value IERC7913SignatureVerifier.verify.selector if the signature is valid.\n     * SHOULD return 0xffffffff or revert if the signature is not valid.\n     * SHOULD return 0xffffffff or revert if the key is empty\n     */\n    function verify(bytes calldata key, bytes32 hash, bytes calldata signature) external view returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.22;\n\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"./ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address implementation, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.21;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This library provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\n */\nlibrary ERC1967Utils {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit IERC1967.Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit IERC1967.BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.22;\n\nimport {ITransparentUpgradeableProxy} from \"./TransparentUpgradeableProxy.sol\";\nimport {Ownable} from \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgrade(address,address)`\n     * and `upgradeAndCall(address,address,bytes)` are present, and `upgrade` must be used if no function should be called,\n     * while `upgradeAndCall` will invoke the `receive` function if the third argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeAndCall(address,address,bytes)` is present, and the third argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev Sets the initial owner who can perform upgrades.\n     */\n    constructor(address initialOwner) Ownable(initialOwner) {}\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.\n     * See {TransparentUpgradeableProxy-_dispatchUpgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.22;\n\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\nimport {ERC1967Proxy} from \"../ERC1967/ERC1967Proxy.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {ProxyAdmin} from \"./ProxyAdmin.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    /// @dev See {UUPSUpgradeable-upgradeToAndCall}\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won't be forwarded to\n * the implementation. If the admin tries to call a function on the implementation it will fail with an error indicating\n * the proxy admin cannot fallback to the target implementation.\n *\n * These properties mean that the admin account can only be used for upgrading the proxy, so it's best if it's a\n * dedicated account that is not used for anything else. This will avoid headaches due to sudden errors when trying to\n * call a function from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and\n * allows upgrades only if they come through it. You should think of the `ProxyAdmin` instance as the administrative\n * interface of the proxy, including the ability to change who can trigger upgrades by transferring ownership.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won't send a\n * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.\n *\n * IMPORTANT: This contract avoids unnecessary storage reads by setting the admin only during construction as an\n * immutable variable, preventing any changes thereafter. However, the admin slot defined in ERC-1967 can still be\n * overwritten by the implementation logic pointed to by this proxy. In such cases, the contract may end up in an\n * undesirable state where the admin slot is different from the actual admin. Relying on the value of the admin slot\n * is generally fine if the implementation is trusted.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the\n * compiler will not check that there are no selector conflicts, due to the note above. A selector clash between any new\n * function and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This\n * could render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    // An immutable address for the admin to avoid unnecessary SLOADs before each call\n    // at the expense of removing the ability to change the admin once it's set.\n    // This is acceptable if the admin is always a ProxyAdmin instance or similar contract\n    // with its own ability to transfer the permissions to another account.\n    address private immutable _admin;\n\n    /**\n     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.\n     */\n    error ProxyDeniedAdminAccess();\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,\n     * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in\n     * {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _admin = address(new ProxyAdmin(initialOwner));\n        // Set the storage value and emit an event for ERC-1967 compatibility\n        ERC1967Utils.changeAdmin(_proxyAdmin());\n    }\n\n    /**\n     * @dev Returns the admin of this proxy.\n     */\n    function _proxyAdmin() internal view virtual returns (address) {\n        return _admin;\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _proxyAdmin()) {\n            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                revert ProxyDeniedAdminAccess();\n            } else {\n                _dispatchUpgradeToAndCall();\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    function _dispatchUpgradeToAndCall() private {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        ERC1967Utils.upgradeToAndCall(newImplementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Bytes.sol)\n\npragma solidity ^0.8.24;\n\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Bytes operations.\n */\nlibrary Bytes {\n    /**\n     * @dev Forward search for `s` in `buffer`\n     * * If `s` is present in the buffer, returns the index of the first instance\n     * * If `s` is not present in the buffer, returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf[Javascript's `Array.indexOf`]\n     */\n    function indexOf(bytes memory buffer, bytes1 s) internal pure returns (uint256) {\n        return indexOf(buffer, s, 0);\n    }\n\n    /**\n     * @dev Forward search for `s` in `buffer` starting at position `pos`\n     * * If `s` is present in the buffer (at or after `pos`), returns the index of the next instance\n     * * If `s` is not present in the buffer (at or after `pos`), returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf[Javascript's `Array.indexOf`]\n     */\n    function indexOf(bytes memory buffer, bytes1 s, uint256 pos) internal pure returns (uint256) {\n        uint256 length = buffer.length;\n        for (uint256 i = pos; i < length; ++i) {\n            if (bytes1(_unsafeReadBytesOffset(buffer, i)) == s) {\n                return i;\n            }\n        }\n        return type(uint256).max;\n    }\n\n    /**\n     * @dev Backward search for `s` in `buffer`\n     * * If `s` is present in the buffer, returns the index of the last instance\n     * * If `s` is not present in the buffer, returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf[Javascript's `Array.lastIndexOf`]\n     */\n    function lastIndexOf(bytes memory buffer, bytes1 s) internal pure returns (uint256) {\n        return lastIndexOf(buffer, s, type(uint256).max);\n    }\n\n    /**\n     * @dev Backward search for `s` in `buffer` starting at position `pos`\n     * * If `s` is present in the buffer (at or before `pos`), returns the index of the previous instance\n     * * If `s` is not present in the buffer (at or before `pos`), returns type(uint256).max\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf[Javascript's `Array.lastIndexOf`]\n     */\n    function lastIndexOf(bytes memory buffer, bytes1 s, uint256 pos) internal pure returns (uint256) {\n        unchecked {\n            uint256 length = buffer.length;\n            for (uint256 i = Math.min(Math.saturatingAdd(pos, 1), length); i > 0; --i) {\n                if (bytes1(_unsafeReadBytesOffset(buffer, i - 1)) == s) {\n                    return i - 1;\n                }\n            }\n            return type(uint256).max;\n        }\n    }\n\n    /**\n     * @dev Copies the content of `buffer`, from `start` (included) to the end of `buffer` into a new bytes object in\n     * memory.\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice[Javascript's `Array.slice`]\n     */\n    function slice(bytes memory buffer, uint256 start) internal pure returns (bytes memory) {\n        return slice(buffer, start, buffer.length);\n    }\n\n    /**\n     * @dev Copies the content of `buffer`, from `start` (included) to `end` (excluded) into a new bytes object in\n     * memory.\n     *\n     * NOTE: replicates the behavior of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice[Javascript's `Array.slice`]\n     */\n    function slice(bytes memory buffer, uint256 start, uint256 end) internal pure returns (bytes memory) {\n        // sanitize\n        uint256 length = buffer.length;\n        end = Math.min(end, length);\n        start = Math.min(start, end);\n\n        // allocate and copy\n        bytes memory result = new bytes(end - start);\n        assembly (\"memory-safe\") {\n            mcopy(add(result, 0x20), add(add(buffer, 0x20), start), sub(end, start))\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly (\"memory-safe\") {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Variant of {toDataWithIntendedValidatorHash-address-bytes} optimized for cases where `data` is a bytes32.\n     */\n    function toDataWithIntendedValidatorHash(\n        address validator,\n        bytes32 messageHash\n    ) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, hex\"19_00\")\n            mstore(0x02, shl(96, validator))\n            mstore(0x16, messageHash)\n            digest := keccak256(0x00, 0x36)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.24;\n\nimport {ECDSA} from \"./ECDSA.sol\";\nimport {IERC1271} from \"../../interfaces/IERC1271.sol\";\nimport {IERC7913SignatureVerifier} from \"../../interfaces/IERC7913.sol\";\nimport {Bytes} from \"../../utils/Bytes.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support:\n *\n * * ECDSA signatures from externally owned accounts (EOAs)\n * * ERC-1271 signatures from smart contract wallets like Argent and Safe Wallet (previously Gnosis Safe)\n * * ERC-7913 signatures from keys that do not have an Ethereum address of their own\n *\n * See https://eips.ethereum.org/EIPS/eip-1271[ERC-1271] and https://eips.ethereum.org/EIPS/eip-7913[ERC-7913].\n */\nlibrary SignatureChecker {\n    using Bytes for bytes;\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer has code, the\n     * signature is validated against it using ERC-1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     *\n     * NOTE: For an extended version of this function that supports ERC-7913 signatures, see {isValidSignatureNow-bytes-bytes32-bytes-}.\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        if (signer.code.length == 0) {\n            (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);\n            return err == ECDSA.RecoverError.NoError && recovered == signer;\n        } else {\n            return isValidERC1271SignatureNow(signer, hash, signature);\n        }\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC-1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n\n    /**\n     * @dev Verifies a signature for a given ERC-7913 signer and hash.\n     *\n     * The signer is a `bytes` object that is the concatenation of an address and optionally a key:\n     * `verifier || key`. A signer must be at least 20 bytes long.\n     *\n     * Verification is done as follows:\n     *\n     * * If `signer.length < 20`: verification fails\n     * * If `signer.length == 20`: verification is done using {isValidSignatureNow}\n     * * Otherwise: verification is done using {IERC7913SignatureVerifier}\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(\n        bytes memory signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        if (signer.length < 20) {\n            return false;\n        } else if (signer.length == 20) {\n            return isValidSignatureNow(address(bytes20(signer)), hash, signature);\n        } else {\n            (bool success, bytes memory result) = address(bytes20(signer)).staticcall(\n                abi.encodeCall(IERC7913SignatureVerifier.verify, (signer.slice(20), hash, signature))\n            );\n            return (success &&\n                result.length >= 32 &&\n                abi.decode(result, (bytes32)) == bytes32(IERC7913SignatureVerifier.verify.selector));\n        }\n    }\n\n    /**\n     * @dev Verifies multiple ERC-7913 `signatures` for a given `hash` using a set of `signers`.\n     * Returns `false` if the number of signers and signatures is not the same.\n     *\n     * The signers should be ordered by their `keccak256` hash to ensure efficient duplication check. Unordered\n     * signers are supported, but the uniqueness check will be more expensive.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function areValidSignaturesNow(\n        bytes32 hash,\n        bytes[] memory signers,\n        bytes[] memory signatures\n    ) internal view returns (bool) {\n        if (signers.length != signatures.length) return false;\n\n        bytes32 lastId = bytes32(0);\n\n        for (uint256 i = 0; i < signers.length; ++i) {\n            bytes memory signer = signers[i];\n\n            // If one of the signatures is invalid, reject the batch\n            if (!isValidSignatureNow(signer, hash, signatures[i])) return false;\n\n            bytes32 id = keccak256(signer);\n            // If the current signer ID is greater than all previous IDs, then this is a new signer.\n            if (lastId < id) {\n                lastId = id;\n            } else {\n                // If this signer id is not greater than all the previous ones, verify that it is not a duplicate of a previous one\n                // This loop is never executed if the signers are ordered by id.\n                for (uint256 j = 0; j < i; ++j) {\n                    if (id == keccak256(signers[j])) return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2 + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2 + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2 + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2 - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/Checkpoints.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/structs/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\n\n/**\n * @dev This library defines the `Trace*` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.Trace*` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n */\nlibrary Checkpoints {\n    /**\n     * @dev A value was attempted to be inserted on a past checkpoint.\n     */\n    error CheckpointUnorderedInsertion();\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint32).max` key set will disable the\n     * library.\n     */\n    function push(\n        Trace224 storage self,\n        uint32 key,\n        uint224 value\n    ) internal returns (uint224 oldValue, uint224 newValue) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimized to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoints.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace224 storage self, uint32 pos) internal view returns (Checkpoint224 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint224 value\n    ) private returns (uint224 oldValue, uint224 newValue) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            Checkpoint224 storage last = _unsafeAccess(self, pos - 1);\n            uint32 lastKey = last._key;\n            uint224 lastValue = last._value;\n\n            // Checkpoint keys must be non-decreasing.\n            if (lastKey > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (lastKey == key) {\n                last._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (lastValue, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace208 {\n        Checkpoint208[] _checkpoints;\n    }\n\n    struct Checkpoint208 {\n        uint48 _key;\n        uint208 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace208 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint48).max` key set will disable the\n     * library.\n     */\n    function push(\n        Trace208 storage self,\n        uint48 key,\n        uint208 value\n    ) internal returns (uint208 oldValue, uint208 newValue) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimized to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace208 storage self) internal view returns (uint208) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint208 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoints.\n     */\n    function length(Trace208 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace208 storage self, uint32 pos) internal view returns (Checkpoint208 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint208 value\n    ) private returns (uint208 oldValue, uint208 newValue) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            Checkpoint208 storage last = _unsafeAccess(self, pos - 1);\n            uint48 lastKey = last._key;\n            uint208 lastValue = last._value;\n\n            // Checkpoint keys must be non-decreasing.\n            if (lastKey > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (lastKey == key) {\n                last._value = value;\n            } else {\n                self.push(Checkpoint208({_key: key, _value: value}));\n            }\n            return (lastValue, value);\n        } else {\n            self.push(Checkpoint208({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint208[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint208 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint96).max` key set will disable the\n     * library.\n     */\n    function push(\n        Trace160 storage self,\n        uint96 key,\n        uint160 value\n    ) internal returns (uint160 oldValue, uint160 newValue) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimized to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoints.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace160 storage self, uint32 pos) internal view returns (Checkpoint160 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint160 value\n    ) private returns (uint160 oldValue, uint160 newValue) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            Checkpoint160 storage last = _unsafeAccess(self, pos - 1);\n            uint96 lastKey = last._key;\n            uint160 lastValue = last._value;\n\n            // Checkpoint keys must be non-decreasing.\n            if (lastKey > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (lastKey == key) {\n                last._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (lastValue, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key strictly bigger than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key greater or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/structs/DoubleEndedQueue.sol)\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```solidity\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n */\nlibrary DoubleEndedQueue {\n    /**\n     * @dev Indices are 128 bits so begin and end are packed in a single storage slot for efficient access.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.\n     */\n    struct Bytes32Deque {\n        uint128 _begin;\n        uint128 _end;\n        mapping(uint128 index => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     *\n     * Reverts with {Panic-RESOURCE_ERROR} if the queue is full.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        unchecked {\n            uint128 backIndex = deque._end;\n            if (backIndex + 1 == deque._begin) Panic.panic(Panic.RESOURCE_ERROR);\n            deque._data[backIndex] = value;\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with {Panic-EMPTY_ARRAY_POP} if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        unchecked {\n            uint128 backIndex = deque._end;\n            if (backIndex == deque._begin) Panic.panic(Panic.EMPTY_ARRAY_POP);\n            --backIndex;\n            value = deque._data[backIndex];\n            delete deque._data[backIndex];\n            deque._end = backIndex;\n        }\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     *\n     * Reverts with {Panic-RESOURCE_ERROR} if the queue is full.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        unchecked {\n            uint128 frontIndex = deque._begin - 1;\n            if (frontIndex == deque._end) Panic.panic(Panic.RESOURCE_ERROR);\n            deque._data[frontIndex] = value;\n            deque._begin = frontIndex;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with {Panic-EMPTY_ARRAY_POP} if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        unchecked {\n            uint128 frontIndex = deque._begin;\n            if (frontIndex == deque._end) Panic.panic(Panic.EMPTY_ARRAY_POP);\n            value = deque._data[frontIndex];\n            delete deque._data[frontIndex];\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        return deque._data[deque._begin];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        unchecked {\n            return deque._data[deque._end - 1];\n        }\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with {Panic-ARRAY_OUT_OF_BOUNDS} if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        if (index >= length(deque)) Panic.panic(Panic.ARRAY_OUT_OF_BOUNDS);\n        // By construction, length is a uint128, so the check above ensures that index can be safely downcast to uint128\n        unchecked {\n            return deque._data[deque._begin + uint128(index)];\n        }\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        unchecked {\n            return uint256(deque._end - deque._begin);\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end == deque._begin;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/types/Time.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/types/Time.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\nimport {SafeCast} from \"../math/SafeCast.sol\";\n\n/**\n * @dev This library provides helpers for manipulating time-related objects.\n *\n * It uses the following types:\n * - `uint48` for timepoints\n * - `uint32` for durations\n *\n * While the library doesn't provide specific types for timepoints and duration, it does provide:\n * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point\n * - additional helper functions\n */\nlibrary Time {\n    using Time for *;\n\n    /**\n     * @dev Get the block timestamp as a Timepoint.\n     */\n    function timestamp() internal view returns (uint48) {\n        return SafeCast.toUint48(block.timestamp);\n    }\n\n    /**\n     * @dev Get the block number as a Timepoint.\n     */\n    function blockNumber() internal view returns (uint48) {\n        return SafeCast.toUint48(block.number);\n    }\n\n    // ==================================================== Delay =====================================================\n    /**\n     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the\n     * future. The \"effect\" timepoint describes when the transitions happens from the \"old\" value to the \"new\" value.\n     * This allows updating the delay applied to some operation while keeping some guarantees.\n     *\n     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for\n     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set\n     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should\n     * still apply for some time.\n     *\n     *\n     * The `Delay` type is 112 bits long, and packs the following:\n     *\n     * ```\n     *   | [uint48]: effect date (timepoint)\n     *   |           | [uint32]: value before (duration)\n     *                      [uint32]: value after (duration)\n     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC\n     * ```\n     *\n     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently\n     * supported.\n     */\n    type Delay is uint112;\n\n    /**\n     * @dev Wrap a duration into a Delay to add the one-step \"update in the future\" feature\n     */\n    function toDelay(uint32 duration) internal pure returns (Delay) {\n        return Delay.wrap(duration);\n    }\n\n    /**\n     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled\n     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.\n     */\n    function _getFullAt(\n        Delay self,\n        uint48 timepoint\n    ) private pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        (valueBefore, valueAfter, effect) = self.unpack();\n        return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the\n     * effect timepoint is 0, then the pending value should not be considered.\n     */\n    function getFull(Delay self) internal view returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        return _getFullAt(self, timestamp());\n    }\n\n    /**\n     * @dev Get the current value.\n     */\n    function get(Delay self) internal view returns (uint32) {\n        (uint32 delay, , ) = self.getFull();\n        return delay;\n    }\n\n    /**\n     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to\n     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the\n     * new delay becomes effective.\n     */\n    function withUpdate(\n        Delay self,\n        uint32 newValue,\n        uint32 minSetback\n    ) internal view returns (Delay updatedDelay, uint48 effect) {\n        uint32 value = self.get();\n        uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));\n        effect = timestamp() + setback;\n        return (pack(value, newValue, effect), effect);\n    }\n\n    /**\n     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).\n     */\n    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        uint112 raw = Delay.unwrap(self);\n\n        valueAfter = uint32(raw);\n        valueBefore = uint32(raw >> 32);\n        effect = uint48(raw >> 64);\n\n        return (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev pack the components into a Delay object.\n     */\n    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {\n        return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));\n    }\n}\n"
    },
    "contracts/core/HyraGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport \"../interfaces/IHyraGovernor.sol\";\nimport \"../security/DAORoleManager.sol\";\n\n/**\n * @title HyraGovernor\n * @notice DAO governance contract for proposal management and voting\n * @dev PRIVILEGED ROLES:\n *      - _governance: Can add/remove security council members\n *      - Security Council: Can create emergency proposals and cancel any proposal\n *      See: https://docs.hyra.network/security for role management guidelines.\n */\ncontract HyraGovernor is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    GovernorUpgradeable,\n    GovernorSettingsUpgradeable,\n    GovernorCountingSimpleUpgradeable,\n    GovernorVotesUpgradeable,\n    GovernorVotesQuorumFractionUpgradeable,\n    GovernorTimelockControlUpgradeable,\n    IHyraGovernor\n{   \n    // ============ State Variables ============\n    mapping(uint256 => ProposalType) public proposalTypes;\n    mapping(uint256 => bool) public proposalCancelled;\n    mapping(address => bool) public securityCouncilMembers;\n    mapping(uint256 => address) private _proposalProposers; // Track proposers for v5\n    uint256 public securityCouncilMemberCount;\n    \n    // DAO Role Manager for decentralized role management\n    DAORoleManager public roleManager;\n    \n    // Quorum percentages (basis points)\n    // Hierarchy: STANDARD < EMERGENCY < UPGRADE < CONSTITUTIONAL\n    uint256 public constant STANDARD_QUORUM = 1000; // 10% - Regular proposals\n    uint256 public constant EMERGENCY_QUORUM = 2000; // 20% - Emergency proposals (increased for security)\n    uint256 public constant UPGRADE_QUORUM = 2500; // 25% - Contract upgrades\n    uint256 public constant CONSTITUTIONAL_QUORUM = 3000; // 30% - Constitutional changes\n    \n    // Minimum quorum to prevent governance attacks\n    uint256 public constant MINIMUM_QUORUM = 100; // 1% minimum\n    \n    // Storage gap for upgradeability\n    uint256[44] private __gap;\n\n    // ============ Events ============\n    event ProposalTypeSet(uint256 indexed proposalId, ProposalType proposalType);\n    event ProposalCancelled(uint256 indexed proposalId);\n    event SecurityCouncilMemberAdded(address indexed member);\n    event SecurityCouncilMemberRemoved(address indexed member);\n    event ProposalCreatedWithType(\n        uint256 indexed proposalId,\n        address proposer,\n        ProposalType proposalType\n    );\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n    event VoteCasted(address indexed voter, uint256 proposalId, uint8 support, uint256 weight);\n\n    // ============ Errors ============\n    error InvalidProposalType();\n    error OnlySecurityCouncil();\n    error NotSecurityCouncilMember();\n    error AlreadySecurityCouncilMember();\n    error ProposalAlreadyCancelled();\n    error UnauthorizedCancellation();\n    error InvalidProposalLength();\n    error ZeroAddress();\n    error ProposalNotFound();\n    error VotingNotActive();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    /**\n     * @notice Initialize the Governor contract\n     * @param _token The voting token (HyraToken)\n     * @param _timelock The timelock controller\n     * @param _votingDelay Delay before voting starts (blocks)\n     * @param _votingPeriod Duration of voting (blocks)\n     * @param _proposalThreshold Min tokens to create proposal\n     * @param _quorumPercentage Initial quorum percentage\n     */\n    function initialize(\n        IVotes _token,\n        TimelockControllerUpgradeable _timelock,\n        uint256 _votingDelay,\n        uint256 _votingPeriod,\n        uint256 _proposalThreshold,\n        uint256 _quorumPercentage\n    ) public initializer {\n        // FIXED: Add zero address validation\n        if (address(_token) == address(0)) revert ZeroAddress();\n        if (address(_timelock) == address(0)) revert ZeroAddress();\n        __Governor_init(\"HyraGovernor\");\n        __GovernorSettings_init(uint48(_votingDelay), uint32(_votingPeriod), _proposalThreshold);\n        __GovernorCountingSimple_init();\n        __GovernorVotes_init(_token);\n        __GovernorVotesQuorumFraction_init(_quorumPercentage);\n        __GovernorTimelockControl_init(_timelock);\n    }\n\n    // ============ Proposal Functions ============\n\n    /**\n     * @notice Create a proposal with specific type\n     * @param targets Target addresses for calls\n     * @param values ETH values for calls\n     * @param calldatas Encoded function calls\n     * @param description Proposal description\n     * @param proposalType Type of proposal\n     */\n    function proposeWithType(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        ProposalType proposalType\n    ) public returns (uint256) {\n        // Validate proposal type\n        if (uint8(proposalType) > uint8(ProposalType.UPGRADE)) {\n            revert InvalidProposalType();\n        }\n        \n        // Emergency proposals require security council\n        if (proposalType == ProposalType.EMERGENCY) {\n            if (!securityCouncilMembers[msg.sender]) {\n                revert OnlySecurityCouncil();\n            }\n        }\n        \n        // Validate proposal arrays\n        if (!_validateProposal(targets, values, calldatas)) {\n            revert InvalidProposalLength();\n        }\n        \n        uint256 proposalId = propose(targets, values, calldatas, description);\n        proposalTypes[proposalId] = proposalType;\n        // Removed duplicate _proposalProposers assignment\n        \n        emit ProposalTypeSet(proposalId, proposalType);\n        emit ProposalCreatedWithType(proposalId, msg.sender, proposalType);\n        \n        return proposalId;\n    }\n\n    /**\n     * @notice Get proposal proposer (required for v5)\n     * @param proposalId The proposal ID\n     */\n    function proposalProposer(uint256 proposalId) public view override(GovernorUpgradeable, IGovernor) returns (address) {\n        return _proposalProposers[proposalId];\n    }\n\n    /**\n     * @notice Cancel a proposal\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public override(GovernorUpgradeable, IGovernor) nonReentrant returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        \n        // Checks: Verify proposal state and authorization\n        ProposalState currentState = state(proposalId);\n        if (currentState == ProposalState.Canceled) {\n            revert ProposalAlreadyCancelled();\n        }\n        \n        // Check authorization - proposer or security council can cancel\n        address proposer = proposalProposer(proposalId);\n        if (msg.sender != proposer && !securityCouncilMembers[msg.sender]) {\n            revert UnauthorizedCancellation();\n        }\n        \n        // Interactions: Call OpenZeppelin's trusted cancel logic first\n        // This allows OZ to handle state transitions properly before we mark it cancelled\n        if (securityCouncilMembers[msg.sender]) {\n            // Directly call internal _cancel function\n            _cancel(targets, values, calldatas, descriptionHash);\n        } else {\n            // For proposers, use parent function\n            super.cancel(targets, values, calldatas, descriptionHash);\n        }\n        \n        // Effects: Update our custom cancellation tracking after OZ cancel completes\n        // This must be done AFTER super.cancel() to avoid interfering with OZ's state() checks\n        proposalCancelled[proposalId] = true;\n        emit ProposalCancelled(proposalId);\n        \n        return proposalId;\n    }\n\n    // ============ DAO Role Management Functions ============\n    \n    /**\n     * @notice Set the DAO Role Manager (only governance)\n     * @param _roleManager Address of the DAO Role Manager\n     */\n    function setRoleManager(DAORoleManager _roleManager) external onlyGovernance {\n        // FIXED: Add zero address validation\n        if (address(_roleManager) == address(0)) revert ZeroAddress();\n        roleManager = _roleManager;\n    }\n\n    // ============ Security Council Functions ============\n\n    /**\n     * @notice Add a security council member (decentralized via DAO role manager)\n     * @param _member Address to add\n     */\n    function addSecurityCouncilMember(address _member) \n        external \n    {\n        if (_member == address(0)) revert ZeroAddress();\n        if (securityCouncilMembers[_member]) revert AlreadySecurityCouncilMember();\n        \n        // Check if caller has governance role through DAO role manager\n        if (address(roleManager) != address(0)) {\n            require(\n                roleManager.hasRole(roleManager.GOVERNANCE_ROLE(), msg.sender),\n                \"Only governance role holders can add security council members\"\n            );\n        } else {\n            // Fallback: only allow if no role manager is set (deployment phase)\n            revert(\"DAO role manager must be set for security council management\");\n        }\n        \n        securityCouncilMembers[_member] = true;\n        securityCouncilMemberCount++;\n        \n        emit SecurityCouncilMemberAdded(_member);\n    }\n\n    /**\n     * @notice Remove a security council member (decentralized via DAO role manager)\n     * @param _member Address to remove\n     */\n    function removeSecurityCouncilMember(address _member) \n        external \n    {\n        if (!securityCouncilMembers[_member]) revert NotSecurityCouncilMember();\n        \n        // Check if caller has governance role through DAO role manager\n        if (address(roleManager) != address(0)) {\n            require(\n                roleManager.hasRole(roleManager.GOVERNANCE_ROLE(), msg.sender),\n                \"Only governance role holders can remove security council members\"\n            );\n        } else {\n            // Fallback: only allow if no role manager is set (deployment phase)\n            revert(\"DAO role manager must be set for security council management\");\n        }\n        \n        securityCouncilMembers[_member] = false;\n        securityCouncilMemberCount--;\n        \n        emit SecurityCouncilMemberRemoved(_member);\n    }\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Validate proposal parameters\n     * @param targets Array of target addresses\n     * @param values Array of ETH values\n     * @param calldatas Array of encoded function calls\n     * @return valid True if parameters are valid\n     */\n    function _validateProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas\n    ) private pure returns (bool valid) {\n        uint256 length = targets.length;\n        valid = length == values.length && \n                length == calldatas.length && \n                length > 0 && \n                length <= 10; // Max 10 operations per proposal\n    }\n\n    /**\n     * @notice Store proposer when proposal is created (v5 requirement)\n     */\n    function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal override returns (uint256 proposalId) {\n        proposalId = super._propose(targets, values, calldatas, description, proposer);\n        _proposalProposers[proposalId] = proposer;\n        return proposalId;\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get custom quorum for a proposal based on its type\n     * @param proposalId The proposal ID\n     * @return The required quorum for this proposal\n     */\n    function getProposalQuorum(uint256 proposalId) \n        public \n        view \n        returns (uint256) \n    {\n        // Validate proposal exists\n        uint256 snapshot = proposalSnapshot(proposalId);\n        if (snapshot == 0) {\n            revert ProposalNotFound();\n        }\n        \n        ProposalType pType = proposalTypes[proposalId];\n        uint256 supply = token().getPastTotalSupply(snapshot);\n        \n        // Prevent division by zero and ensure minimum quorum\n        if (supply == 0) {\n            return 0;\n        }\n        \n        uint256 quorumPercentage;\n        if (pType == ProposalType.EMERGENCY) {\n            quorumPercentage = EMERGENCY_QUORUM;\n        } else if (pType == ProposalType.CONSTITUTIONAL) {\n            quorumPercentage = CONSTITUTIONAL_QUORUM;\n        } else if (pType == ProposalType.UPGRADE) {\n            quorumPercentage = UPGRADE_QUORUM;\n        } else {\n            quorumPercentage = STANDARD_QUORUM;\n        }\n        \n        uint256 calculatedQuorum = (supply * quorumPercentage) / 10000;\n        \n        // Apply minimum quorum protection\n        uint256 minimumQuorum = (supply * MINIMUM_QUORUM) / 10000;\n        \n        return calculatedQuorum > minimumQuorum ? calculatedQuorum : minimumQuorum;\n    }\n\n    /**\n     * @notice Check if address is security council member\n     */\n    function isSecurityCouncilMember(address _account) \n        external \n        view \n        returns (bool) \n    {\n        return securityCouncilMembers[_account];\n    }\n\n    /**\n     * @notice Get quorum percentage for a proposal type\n     * @param proposalType The type of proposal\n     * @return The quorum percentage in basis points\n     */\n    function getQuorumPercentage(ProposalType proposalType) \n        external \n        pure \n        returns (uint256) \n    {\n        if (proposalType == ProposalType.EMERGENCY) {\n            return EMERGENCY_QUORUM;\n        } else if (proposalType == ProposalType.CONSTITUTIONAL) {\n            return CONSTITUTIONAL_QUORUM;\n        } else if (proposalType == ProposalType.UPGRADE) {\n            return UPGRADE_QUORUM;\n        } else {\n            return STANDARD_QUORUM;\n        }\n    }\n\n    /**\n     * @notice Validate quorum hierarchy (for testing/debugging)\n     * @return True if quorum hierarchy is correct\n     */\n    function validateQuorumHierarchy() external pure returns (bool) {\n        return STANDARD_QUORUM < EMERGENCY_QUORUM && \n               EMERGENCY_QUORUM < UPGRADE_QUORUM && \n               UPGRADE_QUORUM < CONSTITUTIONAL_QUORUM &&\n               MINIMUM_QUORUM < STANDARD_QUORUM;\n    }\n\n    // ============ Overrides Required for OpenZeppelin v5 ============\n\n    function quorum(uint256 timepoint) \n        public \n        view \n        override(GovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable, IGovernor) \n        returns (uint256) \n    {\n        // Use the provided timepoint to compute past quorum correctly\n        return super.quorum(timepoint);\n    }\n\n    /**\n     * @notice Override _quorumReached to use proposal-specific quorum\n     * @param proposalId The proposal ID\n     * @return True if quorum is reached\n     */\n    function _quorumReached(uint256 proposalId) \n        internal \n        view \n        override(GovernorCountingSimpleUpgradeable, GovernorUpgradeable) \n        returns (bool) \n    {\n        // Get proposal-specific quorum\n        uint256 requiredQuorum = getProposalQuorum(proposalId);\n        \n        // If no quorum required (edge case), return true\n        if (requiredQuorum == 0) {\n            return true;\n        }\n        \n        // FIXED: Correct destructuring order - proposalVotes returns (againstVotes, forVotes, abstainVotes)\n        // Get current votes (for + abstain votes count toward quorum)\n        (, uint256 forVotes, uint256 abstainVotes) = proposalVotes(proposalId);\n        uint256 currentVotes = forVotes + abstainVotes;\n        \n        return currentVotes >= requiredQuorum;\n    }\n    \n    /**\n     * @notice Override quorum calculation to use proposal-specific quorum\n     * @param proposalId The proposal ID\n     * @return The required quorum for this specific proposal\n     */\n    function quorum(uint256 proposalId, uint256 /* timepoint */) \n        public \n        view \n        returns (uint256) \n    {\n        // Get proposal-specific quorum based on type\n        return getProposalQuorum(proposalId);\n    }\n\n    function votingDelay() \n        public \n        view \n        override(GovernorUpgradeable, GovernorSettingsUpgradeable, IGovernor) \n        returns (uint256) \n    {\n        return super.votingDelay();\n    }\n\n    function votingPeriod() \n        public \n        view \n        override(GovernorUpgradeable, GovernorSettingsUpgradeable, IGovernor) \n        returns (uint256) \n    {\n        return super.votingPeriod();\n    }\n\n    function proposalNeedsQueuing(uint256 proposalId) \n        public \n        view \n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable, IGovernor) \n        returns (bool) \n    {\n        return super.proposalNeedsQueuing(proposalId);\n    }\n\n    function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {\n        super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint48) {\n        return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable, IGovernor)\n        returns (ProposalState)\n    {\n        if (proposalCancelled[proposalId]) {\n            return ProposalState.Canceled;\n        }\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override(GovernorUpgradeable, IGovernor) returns (uint256) {\n        // Validate proposal length\n        _validateProposal(targets, values, calldatas);\n        \n        uint256 proposalId = super.propose(targets, values, calldatas, description);\n        // Removed duplicate _proposalProposers assignment\n        \n        // Set default proposal type as STANDARD\n        proposalTypes[proposalId] = ProposalType.STANDARD;\n        \n        return proposalId;\n    }\n\n    function proposalThreshold()\n        public\n        view\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable, IGovernor)\n        returns (uint256)\n    {\n        return super.proposalThreshold();\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (address)\n    {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(GovernorUpgradeable, IERC165)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @notice Clock mode for v5 (using block number)\n     */\n    function clock() public view override(GovernorUpgradeable, GovernorVotesUpgradeable, IERC6372) returns (uint48) {\n        return super.clock();\n    }\n\n    /**\n     * @notice Clock mode descriptor\n     */\n    function CLOCK_MODE() public view override(GovernorUpgradeable, GovernorVotesUpgradeable, IERC6372) returns (string memory) {\n        return super.CLOCK_MODE();\n    }\n\n}"
    },
    "contracts/core/HyraTimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"../interfaces/IHyraTimelock.sol\";\nimport \"../security/SecureExecutorManager.sol\";\nimport \"../security/ProxyAdminValidator.sol\";\n\n/**\n * @title HyraTimelock\n * @notice Extended TimelockController for Hyra DAO with upgrade management\n */\ncontract HyraTimelock is Initializable, ReentrancyGuardUpgradeable, TimelockControllerUpgradeable, IHyraTimelock {\n    // ============ State Variables ============\n    mapping(address => uint256) public pendingUpgrades;\n    mapping(address => address) public pendingImplementations;\n    mapping(bytes32 => bool) public executedUpgrades;\n    mapping(address => uint256) public upgradeNonce;\n    \n    // Secure Executor Manager for replacing address(0) executors\n    SecureExecutorManager public executorManager;\n    \n    // Proxy Admin Validator for preventing fake proxy admin attacks\n    ProxyAdminValidator public proxyAdminValidator;\n    \n    uint256 public constant UPGRADE_DELAY = 7 days;\n    uint256 public constant EMERGENCY_UPGRADE_DELAY = 2 days;\n\n    uint256[45] private __gap;\n    \n    // ============ Modifiers ============\n    modifier onlyExecutorOrSecureManager() {\n        // Check if using secure executor manager\n        if (address(executorManager) != address(0)) {\n            require(\n                executorManager.isAuthorizedExecutor(msg.sender),\n                \"Only authorized executors can execute\"\n            );\n            _;\n        } else if (hasRole(EXECUTOR_ROLE, address(0))) {\n            // Fallback: allow anyone to execute if address(0) has EXECUTOR_ROLE\n            _;\n        } else {\n            // Only role holders can execute\n            _checkRole(EXECUTOR_ROLE);\n            _;\n        }\n    }\n    \n    // ============ Events ============\n    event UpgradeScheduled(\n        address indexed proxy,\n        address indexed newImplementation,\n        uint256 executeTime,\n        bytes32 upgradeId\n    );\n    event UpgradeCancelled(address indexed proxy, bytes32 upgradeId);\n    event UpgradeExecuted(\n        address indexed proxy,\n        address indexed newImplementation,\n        bytes32 upgradeId\n    );\n    event EmergencyUpgradeScheduled(address indexed proxy, address indexed implementation);\n    event OperationExecuted(bytes32 indexed id, uint256 index, address target, uint256 value);\n\n    // ============ Errors ============\n    error InvalidProxy();\n    error InvalidImplementation();\n    error UpgradeAlreadyScheduled();\n    error NoUpgradeScheduled();\n    error UpgradeNotReady();\n    error UpgradeExpired();\n    error UpgradeAlreadyExecuted();\n    error ExecutionFailed(string reason);\n    error InvalidDelay();\n    error InvalidProxyAdmin();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializer for upgradeable pattern\n     * @param minDelay Minimum delay for operations\n     * @param proposers Array of addresses with proposer role\n     * @param executors Array of addresses with executor role\n     * @param admin Admin address (can be address(0) to renounce)\n     */\n    function initialize(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors,\n        address admin\n    ) public override initializer {\n        __TimelockController_init(minDelay, proposers, executors, admin);\n    }\n\n    // ============ Executor Management ============\n    \n    /**\n     * @notice Set the Secure Executor Manager (only admin)\n     * @param _executorManager Address of the Secure Executor Manager\n     */\n    function setExecutorManager(SecureExecutorManager _executorManager) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        // FIXED: Add zero address validation\n        if (address(_executorManager) == address(0)) revert InvalidProxyAdmin();\n        executorManager = _executorManager;\n    }\n    \n    /**\n     * @notice Set the Proxy Admin Validator (only admin)\n     * @param _proxyAdminValidator Address of the Proxy Admin Validator\n     */\n    function setProxyAdminValidator(ProxyAdminValidator _proxyAdminValidator) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        // FIXED: Add zero address validation\n        if (address(_proxyAdminValidator) == address(0)) revert InvalidProxyAdmin();\n        proxyAdminValidator = _proxyAdminValidator;\n    }\n\n    // ============ Upgrade Management ============\n\n    /**\n     * @notice Schedule an upgrade for a proxy contract\n     * @param proxy Address of the proxy to upgrade\n     * @param newImplementation Address of the new implementation\n     * @param isEmergency Whether this is an emergency upgrade\n     */\n    function scheduleUpgrade(\n        address proxy,\n        address newImplementation,\n        bytes memory /* data */,\n        bool isEmergency\n    ) external override onlyRole(PROPOSER_ROLE) {\n        if (proxy == address(0)) revert InvalidProxy();\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        \n        // Check if there's an expired upgrade that needs to be cleared\n        if (pendingUpgrades[proxy] != 0) {\n            if (block.timestamp > pendingUpgrades[proxy] + 48 hours) {\n                // Clear expired upgrade\n                pendingUpgrades[proxy] = 0;\n                pendingImplementations[proxy] = address(0);\n            } else {\n                revert UpgradeAlreadyScheduled();\n            }\n        }\n        \n        uint256 delay = isEmergency ? EMERGENCY_UPGRADE_DELAY : UPGRADE_DELAY;\n        uint256 executeTime = block.timestamp + delay;\n        \n        pendingUpgrades[proxy] = executeTime;\n        pendingImplementations[proxy] = newImplementation;\n        \n        uint256 nonce = ++upgradeNonce[proxy];\n        bytes32 upgradeId = keccak256(\n            abi.encodePacked(proxy, newImplementation, nonce)\n        );\n        \n        emit UpgradeScheduled(proxy, newImplementation, executeTime, upgradeId);\n        \n        if (isEmergency) {\n            emit EmergencyUpgradeScheduled(proxy, newImplementation);\n        }\n    }\n\n    /**\n     * @notice Cancel a scheduled upgrade\n     * @param proxy Address of the proxy\n     */\n    function cancelUpgrade(address proxy) \n        external \n        override \n        onlyRole(CANCELLER_ROLE) \n    {\n        if (pendingUpgrades[proxy] == 0) revert NoUpgradeScheduled();\n\n        uint256 nonce = upgradeNonce[proxy];\n        bytes32 upgradeId = keccak256(\n            abi.encodePacked(proxy, pendingImplementations[proxy], nonce)\n        );\n        \n        delete pendingUpgrades[proxy];\n        delete pendingImplementations[proxy];\n        \n        emit UpgradeCancelled(proxy, upgradeId);\n    }\n\n    /**\n     * @notice Execute a scheduled upgrade\n     * @param proxyAdmin Address of the ProxyAdmin contract\n     * @param proxy Address of the proxy to upgrade\n     */\n    function executeUpgrade(\n        address proxyAdmin,\n        address proxy\n    ) external override onlyExecutorOrSecureManager nonReentrant {\n        if (proxyAdmin == address(0)) revert InvalidProxyAdmin();\n        if (pendingUpgrades[proxy] == 0) revert NoUpgradeScheduled();\n        if (block.timestamp < pendingUpgrades[proxy]) revert UpgradeNotReady();\n        \n        // Check if upgrade hasn't expired (48 hour window)\n        if (block.timestamp > pendingUpgrades[proxy] + 48 hours) {\n            revert UpgradeExpired();\n        }\n        \n        address newImplementation = pendingImplementations[proxy];\n        uint256 nonce = upgradeNonce[proxy];\n        bytes32 upgradeId = keccak256(\n            abi.encodePacked(proxy, newImplementation, nonce)\n        );\n        \n        if (executedUpgrades[upgradeId]) revert UpgradeAlreadyExecuted();\n        \n        // Validate proxyAdmin is legitimate - check if it's a known proxy admin\n        // This prevents fake proxy admin attacks\n        if (proxyAdmin == address(0)) revert InvalidProxyAdmin();\n        \n        // Check if proxy admin validator is set and validate the proxy admin\n        if (address(proxyAdminValidator) != address(0)) {\n            require(\n                proxyAdminValidator.isAuthorizedProxyAdmin(proxyAdmin),\n                \"Proxy admin not authorized\"\n            );\n        }\n        \n        // FIXED: Apply Checks-Effects-Interactions pattern\n        // 1. Update state first (Effects)\n        executedUpgrades[upgradeId] = true;\n        delete pendingUpgrades[proxy];\n        delete pendingImplementations[proxy];\n        \n        // 2. Then make external calls (Interactions)\n        (bool success, bytes memory returnData) = proxyAdmin.call(\n            abi.encodeWithSignature(\n                \"upgradeAndCall(address,address,bytes)\",\n                proxy,\n                newImplementation,\n                \"\"\n            )\n        );\n        \n        if (!success) {\n            // Revert state changes if external call failed\n            executedUpgrades[upgradeId] = false;\n            pendingUpgrades[proxy] = block.timestamp + 48 hours; // Restore original value\n            pendingImplementations[proxy] = newImplementation;\n            \n            if (returnData.length > 0) {\n                assembly {\n                    let returnData_size := mload(returnData)\n                    revert(add(32, returnData), returnData_size)\n                }\n            } else {\n                revert ExecutionFailed(\"Upgrade execution failed\");\n            }\n        }\n        \n        emit UpgradeExecuted(proxy, newImplementation, upgradeId);\n    }\n\n    /**\n     * @notice Execute upgrade with initialization call\n     * @param proxyAdmin Address of the ProxyAdmin contract\n     * @param proxy Address of the proxy to upgrade\n     * @param data Initialization data\n     */\n    function executeUpgradeWithCall(\n        address proxyAdmin,\n        address proxy,\n        bytes memory data\n    ) external override onlyExecutorOrSecureManager nonReentrant {\n        if (proxyAdmin == address(0)) revert InvalidProxyAdmin();\n        if (pendingUpgrades[proxy] == 0) revert NoUpgradeScheduled();\n        if (block.timestamp < pendingUpgrades[proxy]) revert UpgradeNotReady();\n        \n        if (block.timestamp > pendingUpgrades[proxy] + 48 hours) {\n            revert UpgradeExpired();\n        }\n        \n        address newImplementation = pendingImplementations[proxy];\n        uint256 nonce = upgradeNonce[proxy];\n        bytes32 upgradeId = keccak256(\n            abi.encodePacked(proxy, newImplementation, nonce)\n        );\n        \n        if (executedUpgrades[upgradeId]) revert UpgradeAlreadyExecuted();\n        \n        // Validate proxyAdmin is legitimate - check if it's a known proxy admin\n        // This prevents fake proxy admin attacks\n        if (proxyAdmin == address(0)) revert InvalidProxyAdmin();\n        \n        // Check if proxy admin validator is set and validate the proxy admin\n        if (address(proxyAdminValidator) != address(0)) {\n            require(\n                proxyAdminValidator.isAuthorizedProxyAdmin(proxyAdmin),\n                \"Proxy admin not authorized\"\n            );\n        }\n        \n        // FIXED: Apply Checks-Effects-Interactions pattern\n        // 1. Update state first (Effects)\n        executedUpgrades[upgradeId] = true;\n        delete pendingUpgrades[proxy];\n        delete pendingImplementations[proxy];\n        \n        // 2. Then make external calls (Interactions)\n        (bool success, bytes memory returnData) = proxyAdmin.call(\n            abi.encodeWithSignature(\n                \"upgradeAndCall(address,address,bytes)\",\n                proxy,\n                newImplementation,\n                data\n            )\n        );\n        \n        if (!success) {\n            // Revert state changes if external call failed\n            executedUpgrades[upgradeId] = false;\n            pendingUpgrades[proxy] = block.timestamp + 48 hours; // Restore original value\n            pendingImplementations[proxy] = newImplementation;\n            \n            if (returnData.length > 0) {\n                assembly {\n                    let returnData_size := mload(returnData)\n                    revert(add(32, returnData), returnData_size)\n                }\n            } else {\n                revert ExecutionFailed(\"Upgrade with call execution failed\");\n            }\n        }\n        \n        emit UpgradeExecuted(proxy, newImplementation, upgradeId);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Check if an upgrade is ready to execute\n     * @param proxy Address of the proxy\n     */\n    function isUpgradeReady(address proxy) \n        external \n        view \n        override \n        returns (bool) \n    {\n        return pendingUpgrades[proxy] != 0 && \n               block.timestamp >= pendingUpgrades[proxy] &&\n               block.timestamp <= pendingUpgrades[proxy] + 48 hours;\n    }\n\n    /**\n     * @notice Get upgrade details\n     * @param proxy Address of the proxy\n     */\n    function getUpgradeDetails(address proxy) \n        external \n        view \n        returns (\n            address implementation,\n            uint256 executeTime,\n            bool isScheduled,\n            bool isReady\n        ) \n    {\n        implementation = pendingImplementations[proxy];\n        executeTime = pendingUpgrades[proxy];\n        isScheduled = executeTime != 0;\n        isReady = isScheduled && \n                  block.timestamp >= executeTime && \n                  block.timestamp <= executeTime + 48 hours;\n    }\n}"
    },
    "contracts/core/HyraToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol\";\nimport \"../interfaces/IHyraToken.sol\";\n\n/**\n * @title HyraToken\n * @notice ERC20 governance token with voting capabilities for Hyra DAO\n * @dev Implementation contract with tiered minting schedule\n */\ncontract HyraToken is\n    Initializable,\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    ERC20PermitUpgradeable,\n    ERC20VotesUpgradeable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IHyraToken\n{\n    // ============ Constants ============\n    uint256 public constant MAX_SUPPLY = 50_000_000_000e18; // 50 billion total cap\n    \n    // Minting tiers (annual caps)\n    uint256 public constant TIER1_ANNUAL_CAP = 2_500_000_000e18; // 2.5B per year (5% of 50B)\n    uint256 public constant TIER2_ANNUAL_CAP = 1_500_000_000e18; // 1.5B per year (3% of 50B)\n    uint256 public constant TIER3_ANNUAL_CAP = 750_000_000e18;    // 750M per year (1.5% of 50B)\n    \n    // Time periods \n    uint256 public constant TIER1_END_YEAR = 10;  // Year 1-10\n    uint256 public constant TIER2_END_YEAR = 15;  // Year 11-15\n    uint256 public constant TIER3_END_YEAR = 25;  // Year 16-25\n    uint256 public constant YEAR_DURATION = 365 days;\n    \n    // ============ State Variables ============\n    mapping(address => bool) public minters;\n    mapping(address => uint256) public mintAllowances;\n    // Removed unused governanceAddress - using owner() instead\n    uint256 public totalMintedSupply;\n    \n    // Annual mint tracking\n    uint256 public currentMintYear;\n    uint256 public mintYearStartTime;\n    uint256 public originalMintYearStartTime; // Store original start time for accurate year calculation\n    mapping(uint256 => uint256) public mintedByYear; // Track minted amount by year\n    mapping(uint256 => uint256) public pendingByYear; // Track pending mint requests by year\n    uint256 public constant REQUEST_EXPIRY_PERIOD = 365 days; // 1 year expiry for requests\n    \n    // Mint requests (must be approved by DAO)\n    struct MintRequest {\n        address recipient;\n        uint256 amount;\n        uint256 approvedAt;\n        bool executed;\n        string purpose;\n    }\n    \n    mapping(uint256 => MintRequest) public mintRequests;\n    uint256 public mintRequestCount;\n    uint256 public constant MINT_EXECUTION_DELAY = 2 days;\n    \n    // Storage gap for upgradeability\n    uint256[39] private __gap;\n\n    // ============ Events ============\n    event MinterAdded(address indexed minter);\n    event MinterRemoved(address indexed minter);\n    event MintAllowanceSet(address indexed minter, uint256 allowance);\n    event GovernanceTransferred(address indexed oldGovernance, address indexed newGovernance);\n    event MintRequestCreated(uint256 indexed requestId, address indexed recipient, uint256 amount, string purpose);\n    event MintRequestApproved(uint256 indexed requestId, uint256 executionTime);\n    event MintRequestExecuted(uint256 indexed requestId, address indexed recipient, uint256 amount);\n    event MintRequestCancelled(uint256 indexed requestId);\n    event MintRequestExpired(uint256 indexed requestId);\n    event ExpireOldRequestsCompleted(uint256 expiredCount, uint256 totalProcessed);\n    event TokensMinted(address indexed to, uint256 amount, uint256 newTotalSupply);\n    event MintYearReset(uint256 newYear, uint256 timestamp);\n    event InitialDistribution(address indexed holder, uint256 amount, uint256 timestamp);\n    event TokensPaused(address indexed by);\n    event TokensUnpaused(address indexed by);\n\n    // ============ Errors ============\n    error ZeroAddress();\n    error ExceedsAnnualMintCap(uint256 requested, uint256 available);\n    error ExceedsMaxSupply(uint256 resultingSupply, uint256 maxSupply);\n    error MintingPeriodEnded();\n    error InsufficientMintAllowance(uint256 requested, uint256 available);\n    error NotMinter();\n    error AlreadyMinter();\n    error InvalidAmount();\n    error AlreadyExecuted();\n    error MintDelayNotMet();\n    error DirectMintDisabled();\n    error RequestExpired();\n\n    // ============ Modifiers ============\n    modifier onlyMinter() {\n        if (!minters[msg.sender] && msg.sender != owner()) revert NotMinter();\n        _;\n    }\n\n    modifier validAddress(address _addr) {\n        if (_addr == address(0)) revert ZeroAddress();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the token contract with secure initial distribution\n     * @param _name Token name\n     * @param _symbol Token symbol\n     * @param _initialSupply Initial token supply\n     * @param _vestingContract Address of the vesting contract for secure distribution\n     * @param _governance Initial governance address\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint256 _initialSupply,\n        address _vestingContract,\n        address _governance\n    ) public initializer validAddress(_vestingContract) validAddress(_governance) {\n        __ERC20_init(_name, _symbol);\n        __ERC20Burnable_init();\n        __ERC20Permit_init(_name);\n        __ERC20Votes_init();\n        __Ownable_init(_governance); // set initial owner\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        \n        // Initial supply should not exceed 5% (2.5B) \n        require(_initialSupply <= 2_500_000_000e18, \"Initial supply exceeds 5% of max supply\");\n        \n        if (_initialSupply > 0) {\n            // Mint to vesting contract instead of single holder for security\n            _mint(_vestingContract, _initialSupply);\n            totalMintedSupply = _initialSupply;\n            \n            // Track initial supply in year 1\n            mintedByYear[1] = _initialSupply;\n            \n            // Emit event for transparency - now shows vesting contract\n            emit InitialDistribution(_vestingContract, _initialSupply, block.timestamp);\n        }\n        \n        // Initialize mint year tracking\n        currentMintYear = 1;\n        mintYearStartTime = block.timestamp;\n        originalMintYearStartTime = block.timestamp; // Store original start time\n    }\n    \n    /**\n     * @notice DEPRECATED: Legacy initialize function for backward compatibility\n     * @dev This function is kept for backward compatibility but should not be used\n     * @param _name Token name\n     * @param _symbol Token symbol\n     * @param _initialSupply Initial token supply\n     * @param _initialHolder Address to receive initial supply (DEPRECATED - use vesting)\n     * @param _governance Initial governance address\n     */\n    function initializeLegacy(\n        string memory _name,\n        string memory _symbol,\n        uint256 _initialSupply,\n        address _initialHolder,\n        address _governance\n    ) public initializer validAddress(_initialHolder) validAddress(_governance) {\n        __ERC20_init(_name, _symbol);\n        __ERC20Burnable_init();\n        __ERC20Permit_init(_name);\n        __ERC20Votes_init();\n        __Ownable_init(_governance);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        \n        // Initial supply should not exceed 5% (2.5B) \n        require(_initialSupply <= 2_500_000_000e18, \"Initial supply exceeds 5% of max supply\");\n        \n        if (_initialSupply > 0) {\n            _mint(_initialHolder, _initialSupply);\n            totalMintedSupply = _initialSupply;\n            \n            // Track initial supply in year 1\n            mintedByYear[1] = _initialSupply;\n            \n            // Emit event for transparency\n            emit InitialDistribution(_initialHolder, _initialSupply, block.timestamp);\n        }\n        \n        // Initialize mint year tracking\n        currentMintYear = 1;\n        mintYearStartTime = block.timestamp;\n        originalMintYearStartTime = block.timestamp; // Store original start time\n    }\n\n    // ============ Minting Functions ============\n\n    /**\n     * @notice Create a mint request (only owner/timelock can call)\n     * @param _recipient Address to receive tokens\n     * @param _amount Amount to mint\n     * @param _purpose Purpose of minting (for transparency)\n     */\n    function createMintRequest(\n        address _recipient,\n        uint256 _amount,\n        string memory _purpose\n    ) external onlyOwner validAddress(_recipient) returns (uint256 requestId) {\n        if (_amount == 0) revert InvalidAmount();\n        \n        // Check if we need to reset annual mint tracking\n        _checkAndResetMintYear();\n        \n        // Check if minting period has ended (after year 25)\n        if (currentMintYear > TIER3_END_YEAR) {\n            revert MintingPeriodEnded();\n        }\n        \n        // Year-specific validation\n        uint256 annualCap = _getAnnualMintCap(currentMintYear);\n        uint256 mintedInCurrentYear = mintedByYear[currentMintYear];\n        uint256 pendingInCurrentYear = pendingByYear[currentMintYear];\n        \n        uint256 remainingMintCapacity = annualCap > (mintedInCurrentYear + pendingInCurrentYear) ? \n            annualCap - (mintedInCurrentYear + pendingInCurrentYear) : 0;\n        \n        if (_amount > remainingMintCapacity) {\n            revert ExceedsAnnualMintCap(_amount, remainingMintCapacity);\n        }\n        \n        // Reserve the mint amount for current year with overflow check\n        require(pendingByYear[currentMintYear] + _amount >= pendingByYear[currentMintYear], \"PendingByYear overflow\");\n        pendingByYear[currentMintYear] += _amount;\n        \n        // Check total supply cap\n        if (totalSupply() + _amount > MAX_SUPPLY) {\n            revert ExceedsMaxSupply(totalSupply() + _amount, MAX_SUPPLY);\n        }\n        \n        // Create mint request\n        requestId = mintRequestCount++;\n        mintRequests[requestId] = MintRequest({\n            recipient: _recipient,\n            amount: _amount,\n            approvedAt: block.timestamp,\n            executed: false,\n            purpose: _purpose\n        });\n        \n        emit MintRequestCreated(requestId, _recipient, _amount, _purpose);\n        emit MintRequestApproved(requestId, block.timestamp + MINT_EXECUTION_DELAY);\n    }\n    \n    /**\n     * @notice Execute an approved mint request after delay\n     * @param _requestId ID of the mint request\n     */\n    function executeMintRequest(uint256 _requestId) external nonReentrant {\n        // Validate request ID exists\n        if (_requestId >= mintRequestCount) revert InvalidAmount();\n        \n        MintRequest storage request = mintRequests[_requestId];\n        \n        if (request.amount == 0) revert InvalidAmount();\n        if (request.executed) revert AlreadyExecuted();\n        if (block.timestamp < request.approvedAt + MINT_EXECUTION_DELAY) {\n            revert MintDelayNotMet();\n        }\n        \n        // Check if request has expired\n        if (block.timestamp > request.approvedAt + REQUEST_EXPIRY_PERIOD) {\n            revert RequestExpired();\n        }\n        \n        // Mark as executed\n        request.executed = true;\n        \n        // Update year-specific tracking with overflow/underflow checks\n        uint256 requestYear = _calculateYearFromTimestamp(request.approvedAt);\n        \n        // Check for overflow\n        require(mintedByYear[requestYear] + request.amount >= mintedByYear[requestYear], \"MintedByYear overflow\");\n        require(totalMintedSupply + request.amount >= totalMintedSupply, \"TotalMintedSupply overflow\");\n        \n        // Check for underflow\n        require(pendingByYear[requestYear] >= request.amount, \"PendingByYear underflow\");\n        \n        mintedByYear[requestYear] += request.amount;\n        pendingByYear[requestYear] -= request.amount;\n        totalMintedSupply += request.amount;\n        \n        // Mint tokens\n        _mint(request.recipient, request.amount);\n        \n        emit MintRequestExecuted(_requestId, request.recipient, request.amount);\n        emit TokensMinted(request.recipient, request.amount, totalSupply());\n    }\n    \n    /**\n     * @notice Cancel a mint request (only owner)\n     * @param _requestId ID of the mint request to cancel\n     */\n    function cancelMintRequest(uint256 _requestId) external onlyOwner {\n        // Validate request ID exists\n        if (_requestId >= mintRequestCount) revert InvalidAmount();\n        \n        MintRequest storage request = mintRequests[_requestId];\n        \n        if (request.amount == 0) revert InvalidAmount();\n        if (request.executed) revert AlreadyExecuted();\n        \n        // Update year-specific pending tracking with underflow check\n        uint256 requestYear = _calculateYearFromTimestamp(request.approvedAt);\n        require(pendingByYear[requestYear] >= request.amount, \"PendingByYear underflow\");\n        pendingByYear[requestYear] -= request.amount;\n        \n        // Clear the request\n        delete mintRequests[_requestId];\n        \n        emit MintRequestCancelled(_requestId);\n    }\n\n    /**\n     * @notice DEPRECATED: Direct mint is disabled, use createMintRequest instead\n     */\n    function mint(address, uint256) external pure {\n        revert DirectMintDisabled();\n    }\n\n    /**\n     * @notice Get the annual mint cap for a specific year\n     * @param year The year number (1-based)\n     * @return Annual mint cap for that year\n     */\n    function _getAnnualMintCap(uint256 year) private pure returns (uint256) {\n        // FIXED: Use range checks instead of strict equality\n        if (year < 1 || year > TIER3_END_YEAR) {\n            return 0; // No minting allowed\n        }\n        \n        if (year <= TIER1_END_YEAR) {\n            // Year 1-10: 2.5B per year\n            return TIER1_ANNUAL_CAP;\n        } else if (year <= TIER2_END_YEAR) {\n            // Year 11-15: 1.5B per year\n            return TIER2_ANNUAL_CAP;\n        } else {\n            // Year 16-25: 750M per year\n            return TIER3_ANNUAL_CAP;\n        }\n    }\n\n    /**\n     * @notice Check and reset mint year if needed\n     */\n    function _checkAndResetMintYear() private {\n        if (block.timestamp >= mintYearStartTime + YEAR_DURATION) {\n            // Calculate how many years have passed\n            uint256 yearsPassed = (block.timestamp - mintYearStartTime) / YEAR_DURATION;\n            \n            currentMintYear += yearsPassed;\n            mintYearStartTime += yearsPassed * YEAR_DURATION;\n            \n            emit MintYearReset(currentMintYear, block.timestamp);\n        }\n    }\n\n    // ============ Minter Management ============\n\n    /**\n     * @notice Add a new minter\n     * @param _minter Address to grant minting permission\n     */\n    function addMinter(address _minter) \n        external \n        override \n        onlyOwner \n        validAddress(_minter) \n    {\n        if (minters[_minter]) revert AlreadyMinter();\n        minters[_minter] = true;\n        emit MinterAdded(_minter);\n    }\n\n    /**\n     * @notice Remove a minter\n     * @param _minter Address to revoke minting permission\n     */\n    function removeMinter(address _minter) external override onlyOwner {\n        if (!minters[_minter]) revert NotMinter();\n        minters[_minter] = false;\n        delete mintAllowances[_minter];\n        emit MinterRemoved(_minter);\n    }\n\n    /**\n     * @notice Set mint allowance for a minter\n     * @param _minter Address of the minter\n     * @param _allowance Amount allowed to mint\n     */\n    function setMintAllowance(address _minter, uint256 _allowance) \n        external \n        override \n        onlyOwner \n    {\n        mintAllowances[_minter] = _allowance;\n        emit MintAllowanceSet(_minter, _allowance);\n    }\n\n    // ============ Governance Functions ============\n\n    /**\n     * @notice Transfer governance to a new address\n     * @param _newGovernance New governance address\n     */\n    function transferGovernance(address _newGovernance) \n        external \n        override \n        onlyOwner \n        validAddress(_newGovernance) \n    {\n        // Removed unused governanceAddress transfer\n        address oldOwner = owner();\n        _transferOwnership(_newGovernance);\n        emit GovernanceTransferred(oldOwner, _newGovernance);\n    }\n\n    /**\n     * @notice Pause token transfers\n     */\n    function pause() external override onlyOwner {\n        _pause();\n        emit TokensPaused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause token transfers\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n        emit TokensUnpaused(msg.sender);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Check if an address is a minter\n     */\n    function isMinter(address _account) external view override returns (bool) {\n        return minters[_account] || _account == owner();\n    }\n\n    /**\n     * @notice Get remaining mint capacity for current year\n     * @return Available mint amount for the rest of the year\n     */\n    function getRemainingMintCapacity() external view returns (uint256) {\n        // Check if minting period has ended\n        uint256 year = currentMintYear;\n        if (block.timestamp >= mintYearStartTime + YEAR_DURATION) {\n            year += (block.timestamp - mintYearStartTime) / YEAR_DURATION;\n        }\n        \n        if (year > TIER3_END_YEAR) {\n            return 0; // Minting period ended\n        }\n        \n        // Use year-specific logic\n        return this.getRemainingMintCapacityForYear(year);\n    }\n\n    /**\n     * @notice Get remaining mint capacity for a specific year\n     * @param year The year number\n     * @return Available mint amount for that year\n     */\n    function getRemainingMintCapacityForYear(uint256 year) external view returns (uint256) {\n        // FIXED: Validate year parameter - use range checks\n        if (year < 1 || year > TIER3_END_YEAR) {\n            return 0;\n        }\n        \n        uint256 annualCap = _getAnnualMintCap(year);\n        uint256 mintedInYear = mintedByYear[year];\n        uint256 pendingInYear = pendingByYear[year];\n        \n        return annualCap > (mintedInYear + pendingInYear) ? \n            annualCap - (mintedInYear + pendingInYear) : 0;\n    }\n\n    /**\n     * @notice Get pending mint amount for a specific year\n     * @param year The year number\n     * @return Pending mint amount for that year\n     */\n    function getPendingMintAmountForYear(uint256 year) external view returns (uint256) {\n        // FIXED: Validate year parameter - use range checks\n        if (year < 1 || year > TIER3_END_YEAR) {\n            return 0;\n        }\n        return pendingByYear[year];\n    }\n\n    /**\n     * @notice Get minted amount for a specific year\n     * @param year The year number\n     * @return Minted amount for that year\n     */\n    function getMintedAmountForYear(uint256 year) external view returns (uint256) {\n        // FIXED: Validate year parameter - use range checks\n        if (year < 1 || year > TIER3_END_YEAR) {\n            return 0;\n        }\n        return mintedByYear[year];\n    }\n\n    /**\n     * @notice Get total pending mint amount across all years\n     * @return Total pending mint amount\n     */\n    function getTotalPendingMintAmount() external view returns (uint256) {\n        // Optimized: Only check years that might have pending amounts\n        // Most years will be 0, so we can skip them\n        uint256 totalPending = 0;\n        \n        // Check current year and nearby years (most likely to have pending amounts)\n        uint256 currentYear = currentMintYear;\n        for (uint256 year = currentYear > 0 ? currentYear - 1 : 1; \n             year <= currentYear + 1 && year <= TIER3_END_YEAR; \n             year++) {\n            totalPending += pendingByYear[year];\n        }\n        \n        return totalPending;\n    }\n\n    /**\n     * @notice Get count of expired requests that need cleanup\n     * @return Number of expired requests\n     */\n    function getExpiredRequestsCount() external view returns (uint256) {\n        uint256 currentTime = block.timestamp;\n        uint256 expiredCount = 0;\n        \n        // Optimized: Limit the number of iterations to prevent gas limit issues\n        uint256 maxIterations = mintRequestCount > 100 ? 100 : mintRequestCount;\n        \n        for (uint256 i = 0; i < maxIterations; i++) {\n            MintRequest storage request = mintRequests[i];\n            \n            if (!request.executed && \n                currentTime > request.approvedAt + REQUEST_EXPIRY_PERIOD) {\n                expiredCount++;\n            }\n        }\n        \n        return expiredCount;\n    }\n\n    /**\n     * @notice Get the current minting tier\n     * @return tier Current tier (1, 2, 3, or 0 if ended)\n     */\n    function getCurrentMintTier() external view returns (uint256 tier) {\n        uint256 year = currentMintYear;\n        if (block.timestamp >= mintYearStartTime + YEAR_DURATION) {\n            year += (block.timestamp - mintYearStartTime) / YEAR_DURATION;\n        }\n        \n        // FIXED: Use range checks instead of strict equality\n        if (year < 1 || year > TIER3_END_YEAR) {\n            return 0; // No tier (minting ended)\n        } else if (year <= TIER1_END_YEAR) {\n            return 1;\n        } else if (year <= TIER2_END_YEAR) {\n            return 2;\n        } else {\n            return 3;\n        }\n    }\n\n    /**\n     * @notice Get amount minted in current year\n     */\n    function getMintedThisYear() external view returns (uint256) {\n        uint256 year = currentMintYear;\n        if (block.timestamp >= mintYearStartTime + YEAR_DURATION) {\n            year += (block.timestamp - mintYearStartTime) / YEAR_DURATION;\n        }\n        return mintedByYear[year];\n    }\n\n    /**\n     * @notice Get time until next mint year\n     * @return Seconds until mint year resets\n     */\n    function getTimeUntilNextMintYear() external view returns (uint256) {\n        uint256 nextYearTime = mintYearStartTime + YEAR_DURATION;\n        return nextYearTime > block.timestamp ? \n            nextYearTime - block.timestamp : 0;\n    }\n\n    /**\n     * @notice Get total maximum mintable supply over 25 years\n     * @return Total of all tier caps plus initial mint (42.5B tokens)\n     */\n    function getMaxMintableSupply() external pure returns (uint256) {\n        return 2_500_000_000e18 +         // Initial mint: 2.5B\n               (TIER1_ANNUAL_CAP * 10) +  // Year 1-10: 25B\n               (TIER2_ANNUAL_CAP * 5) +   // Year 11-15: 7.5B\n               (TIER3_ANNUAL_CAP * 10);   // Year 16-25: 7.5B\n               // Total: 42.5B (85% of MAX_SUPPLY)\n               // Reserved: 7.5B (15% never minted)\n    }\n\n    // ============ Internal Functions ============\n\n    function _update(\n        address from,\n        address to,\n        uint256 value\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) whenNotPaused {\n        super._update(from, to, value);\n    }\n\n    function nonces(address owner)\n        public\n        view\n        override(ERC20PermitUpgradeable, NoncesUpgradeable)\n        returns (uint256)\n    {\n        return super.nonces(owner);\n    }\n\n    // ============ Helper Functions ============\n    \n    /**\n     * @notice Manually expire old requests to prevent accumulation\n     * @dev Cancels requests older than REQUEST_EXPIRY_PERIOD within specified range\n     * @param startId Starting request ID (inclusive)\n     * @param endId Ending request ID (exclusive)\n     * @return expiredCount Number of requests actually expired\n     */\n    function expireOldRequests(uint256 startId, uint256 endId) external onlyOwner returns (uint256 expiredCount) {\n        // Validate parameters\n        require(startId < endId, \"Invalid range: startId must be less than endId\");\n        require(endId <= mintRequestCount, \"Invalid range: endId exceeds total requests\");\n        require(endId - startId <= 1000, \"Range too large: maximum 1000 requests per call\");\n        \n        uint256 currentTime = block.timestamp;\n        \n        for (uint256 i = startId; i < endId; i++) {\n            MintRequest storage request = mintRequests[i];\n            \n            // Check if request is not executed and has expired\n            if (!request.executed && \n                request.amount > 0 && // Check if request exists\n                currentTime > request.approvedAt + REQUEST_EXPIRY_PERIOD) {\n                \n                // Auto-cancel expired request with underflow check\n                uint256 requestYear = _calculateYearFromTimestamp(request.approvedAt);\n                require(pendingByYear[requestYear] >= request.amount, \"PendingByYear underflow\");\n                pendingByYear[requestYear] -= request.amount;\n                \n                delete mintRequests[i];\n                emit MintRequestExpired(i);\n                expiredCount++;\n            }\n        }\n        \n        emit ExpireOldRequestsCompleted(expiredCount, endId - startId);\n        return expiredCount;\n    }\n\n    /**\n     * @notice Expire all old requests in batches (use with caution for large datasets)\n     * @dev Expires all requests older than REQUEST_EXPIRY_PERIOD by processing in batches\n     * @param batchSize Number of requests to process per batch (max 1000)\n     * @return totalExpired Total number of requests expired across all batches\n     */\n    function expireAllOldRequests(uint256 batchSize) external onlyOwner returns (uint256 totalExpired) {\n        require(batchSize > 0 && batchSize <= 1000, \"Invalid batchSize: must be 1-1000\");\n        \n        uint256 currentTime = block.timestamp;\n        uint256 processed = 0;\n        \n        for (uint256 i = 0; i < mintRequestCount && processed < batchSize; i++) {\n            MintRequest storage request = mintRequests[i];\n            \n            // Skip already deleted or executed requests\n            if (request.amount == 0 || request.executed) {\n                continue;\n            }\n            \n            // Check if request has expired\n            if (currentTime > request.approvedAt + REQUEST_EXPIRY_PERIOD) {\n                uint256 requestYear = _calculateYearFromTimestamp(request.approvedAt);\n                require(pendingByYear[requestYear] >= request.amount, \"PendingByYear underflow\");\n                pendingByYear[requestYear] -= request.amount;\n                \n                delete mintRequests[i];\n                emit MintRequestExpired(i);\n                totalExpired++;\n            }\n            \n            processed++;\n        }\n        \n        emit ExpireOldRequestsCompleted(totalExpired, processed);\n        return totalExpired;\n    }\n\n    /**\n     * @notice Calculate year from timestamp based on contract's year tracking\n     * @param timestamp The timestamp to convert\n     * @return year The year number based on contract's mintYearStartTime\n     */\n    function _calculateYearFromTimestamp(uint256 timestamp) internal view returns (uint256) {\n        if (timestamp < originalMintYearStartTime) {\n            return 1; // Before contract start, assume year 1\n        }\n        \n        // Calculate which year the timestamp falls into based on original start time\n        uint256 yearsPassed = (timestamp - originalMintYearStartTime) / YEAR_DURATION;\n        return 1 + yearsPassed; // Year 1 + years passed\n    }\n}"
    },
    "contracts/interfaces/IHyraGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/governance/IGovernor.sol\";\n\n/**\n * @title IHyraGovernor\n * @notice Minimal interface for HyraGovernor - only essential public functions\n */\ninterface IHyraGovernor is IGovernor {\n    // Proposal type enum \n    enum ProposalType {\n        STANDARD,\n        EMERGENCY,\n        CONSTITUTIONAL,\n        UPGRADE\n    }\n    \n    // Core governance functions\n    function proposeWithType(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        ProposalType proposalType\n    ) external returns (uint256);\n    \n    // Security council management\n    function addSecurityCouncilMember(address member) external;\n    function removeSecurityCouncilMember(address member) external;\n    \n    // Essential view functions\n    function proposalTypes(uint256 proposalId) external view returns (ProposalType);\n    function getProposalQuorum(uint256 proposalId) external view returns (uint256);\n    function isSecurityCouncilMember(address account) external view returns (bool);\n}"
    },
    "contracts/interfaces/IHyraProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\n/**\n * @title IHyraProxyAdmin\n * @notice Minimal interface for HyraProxyAdmin - only essential public functions\n */\ninterface IHyraProxyAdmin {\n    // Core proxy management\n    function addProxy(address proxy, string memory name) external;\n    function removeProxy(address proxy) external;\n    function batchUpgrade(\n        address[] calldata proxies,\n        address[] calldata implementations\n    ) external;\n    \n    // Essential view functions\n    function isManaged(address proxy) external view returns (bool);\n    function getManagedProxies() external view returns (address[] memory);\n}"
    },
    "contracts/interfaces/IHyraProxyDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\n/**\n * @title IHyraProxyDeployer\n * @notice Minimal interface for HyraProxyDeployer - only essential public functions\n */\ninterface IHyraProxyDeployer {\n    // Core deployment function\n    function deployProxy(\n        address implementation,\n        address proxyAdmin,\n        bytes memory initData,\n        string memory contractType\n    ) external returns (address proxy);\n    \n    // Essential view functions\n    function isDeployedProxy(address proxy) external view returns (bool);\n}"
    },
    "contracts/interfaces/IHyraTimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\n/**\n * @title IHyraTimelock\n * @notice Minimal interface for HyraTimelock - only essential public functions\n */\ninterface IHyraTimelock {\n    // Core upgrade management functions\n    function scheduleUpgrade(\n        address proxy,\n        address newImplementation,\n        bytes memory data,\n        bool isEmergency\n    ) external;\n    \n    function cancelUpgrade(address proxy) external;\n    \n    function executeUpgrade(address proxyAdmin, address proxy) external;\n    \n    function executeUpgradeWithCall(\n        address proxyAdmin,\n        address proxy,\n        bytes memory data\n    ) external;\n    \n    // Essential view functions\n    function isUpgradeReady(address proxy) external view returns (bool);\n    function pendingUpgrades(address proxy) external view returns (uint256);\n    function pendingImplementations(address proxy) external view returns (address);\n}"
    },
    "contracts/interfaces/IHyraToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\n\n/**\n * @title IHyraToken\n * @notice Minimal interface for HyraToken - only essential public functions\n */\ninterface IHyraToken is IERC20, IVotes {\n    // Core minting functions that external contracts need\n    function mint(address to, uint256 amount) external;\n    function addMinter(address minter) external;\n    function removeMinter(address minter) external;\n    function setMintAllowance(address minter, uint256 allowance) external;\n    \n    // Governance transfer\n    function transferGovernance(address newGovernance) external;\n    \n    // Pause functionality\n    function pause() external;\n    function unpause() external;\n    \n    // Essential view functions for external contracts\n    function isMinter(address account) external view returns (bool);\n    function mintAllowances(address minter) external view returns (uint256);\n    function totalMintedSupply() external view returns (uint256);\n}"
    },
    "contracts/interfaces/IMultiSigProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\n/**\n * @title IMultiSigProxyAdmin\n * @notice Interface for MultiSigProxyAdmin contract\n */\ninterface IMultiSigProxyAdmin {\n    \n    // ============ Structs ============\n    struct PendingUpgrade {\n        address implementation;\n        uint256 executeTime;\n        bool isEmergency;\n        string reason;\n        address proposer;\n    }\n    \n    // ============ Events ============\n    event UpgradeProposed(\n        address indexed proxy,\n        address indexed implementation,\n        uint256 executeTime,\n        bool isEmergency,\n        string reason,\n        bytes32 upgradeId\n    );\n    \n    event UpgradeExecuted(\n        address indexed proxy,\n        address indexed implementation,\n        bytes32 upgradeId\n    );\n    \n    event UpgradeCancelled(\n        address indexed proxy,\n        bytes32 upgradeId\n    );\n    \n    event SignatureAdded(\n        bytes32 indexed upgradeId,\n        address indexed signer,\n        uint256 signatureCount,\n        uint256 requiredSignatures\n    );\n    \n    // ============ Functions ============\n    \n    /**\n     * @notice Initialize the MultiSigProxyAdmin\n     * @param initialOwner The initial owner (should be multisig wallet)\n     * @param _requiredSignatures Number of signatures required for upgrades\n     */\n    function initialize(address initialOwner, uint256 _requiredSignatures) external;\n    \n    /**\n     * @notice Propose an upgrade with multi-signature requirement\n     * @param proxy Address of the proxy to upgrade\n     * @param implementation Address of the new implementation\n     * @param isEmergency Whether this is an emergency upgrade\n     * @param reason Reason for the upgrade\n     */\n    function proposeUpgrade(\n        address proxy,\n        address implementation,\n        bool isEmergency,\n        string memory reason\n    ) external;\n    \n    /**\n     * @notice Sign an upgrade proposal\n     * @param upgradeId The upgrade proposal ID\n     */\n    function signUpgrade(bytes32 upgradeId) external;\n    \n    /**\n     * @notice Execute an upgrade after sufficient signatures and delay\n     * @param proxy Address of the proxy to upgrade\n     */\n    function executeUpgrade(address proxy) external;\n    \n    /**\n     * @notice Cancel a pending upgrade\n     * @param proxy Address of the proxy\n     */\n    function cancelUpgrade(address proxy) external;\n    \n    /**\n     * @notice Batch propose upgrades for multiple proxies\n     * @param proxies Array of proxy addresses\n     * @param implementations Array of new implementation addresses\n     * @param reasons Array of reasons for each upgrade\n     */\n    function batchProposeUpgrade(\n        address[] calldata proxies,\n        address[] calldata implementations,\n        string[] calldata reasons\n    ) external;\n    \n    // ============ View Functions ============\n    \n    /**\n     * @notice Get pending upgrade information\n     * @param proxy Address of the proxy\n     * @return upgrade Pending upgrade details\n     */\n    function getPendingUpgrade(address proxy) external view returns (PendingUpgrade memory upgrade);\n    \n    /**\n     * @notice Check if upgrade can be executed\n     * @param proxy Address of the proxy\n     * @return canExecute Whether upgrade can be executed\n     * @return reason Reason if cannot execute\n     */\n    function canExecuteUpgrade(address proxy) external view returns (bool canExecute, string memory reason);\n    \n    /**\n     * @notice Get signature count for an upgrade\n     * @param upgradeId The upgrade proposal ID\n     * @return count Number of signatures\n     */\n    function getSignatureCount(bytes32 upgradeId) external view returns (uint256 count);\n    \n    /**\n     * @notice Check if an address has signed an upgrade\n     * @param upgradeId The upgrade proposal ID\n     * @param signer Address to check\n     * @return hasSigned Whether the address has signed\n     */\n    function hasSigned(bytes32 upgradeId, address signer) external view returns (bool hasSigned);\n}\n"
    },
    "contracts/interfaces/ITokenVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\n/**\n * @title ITokenVesting\n * @notice Interface for gradual token distribution contract\n */\ninterface ITokenVesting {\n    \n    // ============ Structs ============\n    struct VestingSchedule {\n        bool initialized;        // Whether initialized\n        bool revocable;         // Whether revocable\n        uint256 totalAmount;    // Total tokens to be vested\n        uint256 releasedAmount; // Amount of tokens already released\n        uint256 startTime;      // Vesting start time\n        uint256 duration;       // Vesting duration (seconds)\n        uint256 cliff;          // Cliff duration (seconds)\n        address beneficiary;    // Token recipient\n        string purpose;         // Purpose of token usage\n    }\n    \n    // ============ Events ============\n    event VestingScheduleCreated(\n        bytes32 indexed vestingScheduleId,\n        address indexed beneficiary,\n        uint256 totalAmount,\n        uint256 startTime,\n        uint256 duration,\n        uint256 cliff,\n        string purpose\n    );\n    \n    event TokensReleased(\n        bytes32 indexed vestingScheduleId,\n        address indexed beneficiary,\n        uint256 amount,\n        uint256 timestamp\n    );\n    \n    event VestingScheduleRevoked(\n        bytes32 indexed vestingScheduleId,\n        address indexed beneficiary,\n        uint256 revokedAmount,\n        uint256 timestamp\n    );\n    \n    event EmergencyWithdraw(address indexed token, uint256 amount, uint256 timestamp);\n    \n    // ============ Functions ============\n    \n    /**\n     * @notice Initialize vesting contract\n     * @param _token ERC20 token address\n     * @param _owner Contract owner\n     */\n    function initialize(address _token, address _owner) external;\n    \n    /**\n     * @notice Create new vesting schedule\n     * @param _beneficiary Token recipient\n     * @param _totalAmount Total token amount\n     * @param _startTime Start time\n     * @param _duration Vesting duration\n     * @param _cliff Cliff duration\n     * @param _revocable Whether revocable\n     * @param _purpose Purpose of usage\n     * @return vestingScheduleId Vesting schedule ID\n     */\n    function createVestingSchedule(\n        address _beneficiary,\n        uint256 _totalAmount,\n        uint256 _startTime,\n        uint256 _duration,\n        uint256 _cliff,\n        bool _revocable,\n        string memory _purpose\n    ) external returns (bytes32 vestingScheduleId);\n    \n    /**\n     * @notice Release vested tokens\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return releasedAmount Amount of tokens released\n     */\n    function release(bytes32 _vestingScheduleId) external returns (uint256 releasedAmount);\n    \n    /**\n     * @notice Release tokens for all schedules of a beneficiary\n     * @param _beneficiary Token recipient\n     * @return totalReleased Total amount of tokens released\n     */\n    function releaseAllForBeneficiary(address _beneficiary) external returns (uint256 totalReleased);\n    \n    /**\n     * @notice Revoke vesting schedule\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return revokedAmount Amount of tokens revoked\n     */\n    function revoke(bytes32 _vestingScheduleId) external returns (uint256 revokedAmount);\n    \n    /**\n     * @notice Emergency token withdrawal\n     * @param _amount Amount of tokens to withdraw\n     */\n    function emergencyWithdraw(uint256 _amount) external;\n    \n    // ============ View Functions ============\n    \n    /**\n     * @notice Calculate releasable token amount\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return Releasable token amount\n     */\n    function getReleasableAmount(bytes32 _vestingScheduleId) external view returns (uint256);\n    \n    /**\n     * @notice Calculate vested token amount\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return Vested token amount\n     */\n    function getVestedAmount(bytes32 _vestingScheduleId) external view returns (uint256);\n    \n    /**\n     * @notice Get detailed vesting schedule information\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return schedule Detailed information\n     */\n    function getVestingSchedule(bytes32 _vestingScheduleId) external view returns (VestingSchedule memory schedule);\n    \n    /**\n     * @notice Calculate total releasable tokens for a beneficiary\n     * @param _beneficiary Token recipient\n     * @return Total releasable token amount\n     */\n    function getTotalReleasableAmount(address _beneficiary) external view returns (uint256);\n    \n    /**\n     * @notice Get vesting schedule by ID\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return schedule Vesting schedule\n     */\n    function vestingSchedules(bytes32 _vestingScheduleId) external view returns (VestingSchedule memory schedule);\n    \n    /**\n     * @notice Get total vested tokens for a beneficiary\n     * @param _beneficiary Token recipient\n     * @return Total vested token amount\n     */\n    function totalVestedAmount(address _beneficiary) external view returns (uint256);\n    \n    /**\n     * @notice Get total released tokens for a beneficiary\n     * @param _beneficiary Token recipient\n     * @return Total released token amount\n     */\n    function totalReleasedAmount(address _beneficiary) external view returns (uint256);\n}\n"
    },
    "contracts/mock/HyraTokenUpgradeTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"../core/HyraToken.sol\";\n\n// Mock contract for testing upgrade\ncontract HyraTokenV2 is HyraToken {\n    function version() external pure returns (string memory) { return \"test_upgrade\"; }\n}\n"
    },
    "contracts/mock/MaliciousReentrancyContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ncontract MaliciousReentrancyContract {\n    address public governor;\n    bool public reentrancyAttempted = false;\n\n    constructor(address _governor) {\n        governor = _governor;\n    }\n\n    function attemptReentrancy() external {\n        // Placeholder to simulate an attempt; does not actually reenter\n        reentrancyAttempted = true;\n    }\n}\n\ncontract MaliciousTimelockReentrancy {\n    address public timelock;\n    bool public reentrancyAttempted = false;\n\n    constructor(address _timelock) {\n        timelock = _timelock;\n    }\n\n    function attemptReentrancy() external {\n        // Placeholder to simulate an attempt; does not actually reenter\n        reentrancyAttempted = true;\n    }\n}\n\n\n"
    },
    "contracts/mock/MockMultiSigWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\n/**\n * @title MockMultiSigWallet\n * @notice Mock implementation of a multi-signature wallet for testing\n * @dev Simulates Gnosis Safe functionality for HNA-02 security testing\n */\ncontract MockMultiSigWallet is AccessControlUpgradeable {\n    \n    // ============ Constants ============\n    bytes32 public constant SIGNER_ROLE = keccak256(\"SIGNER_ROLE\");\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    \n    // ============ State Variables ============\n    address[] public signers;\n    uint256 public requiredSignatures;\n    uint256 public nonce;\n    \n    // Transaction tracking\n    struct Transaction {\n        address to;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 confirmations;\n        mapping(address => bool) confirmed;\n    }\n    \n    mapping(uint256 => Transaction) public transactions;\n    \n    // ============ Events ============\n    event TransactionSubmitted(\n        uint256 indexed txId,\n        address indexed to,\n        uint256 value,\n        bytes data\n    );\n    \n    event TransactionConfirmed(\n        uint256 indexed txId,\n        address indexed signer\n    );\n    \n    event TransactionExecuted(\n        uint256 indexed txId,\n        bool success,\n        bytes returnData\n    );\n    \n    event SignerAdded(address indexed signer);\n    event SignerRemoved(address indexed signer);\n    event RequiredSignaturesUpdated(uint256 oldRequired, uint256 newRequired);\n    \n    // ============ Errors ============\n    error InvalidSigner();\n    error InsufficientSignatures();\n    error TransactionAlreadyExecuted();\n    error TransactionNotConfirmed();\n    error AlreadyConfirmed();\n    error InvalidRequiredSignatures();\n    error Unauthorized();\n    error TransactionFailed();\n    \n    /**\n     * @notice Initialize the multi-signature wallet\n     * @param _signers Array of signer addresses\n     * @param _requiredSignatures Number of signatures required\n     */\n    function initialize(\n        address[] memory _signers,\n        uint256 _requiredSignatures\n    ) external initializer {\n        if (_signers.length == 0) revert InvalidSigner();\n        if (_requiredSignatures == 0 || _requiredSignatures > _signers.length) {\n            revert InvalidRequiredSignatures();\n        }\n        \n        __AccessControl_init();\n        \n        requiredSignatures = _requiredSignatures;\n        \n        // FIXED: Add event for required signatures\n        emit RequiredSignaturesUpdated(0, _requiredSignatures);\n        \n        // Add signers\n        for (uint256 i = 0; i < _signers.length; i++) {\n            if (_signers[i] == address(0)) revert InvalidSigner();\n            signers.push(_signers[i]);\n            _grantRole(SIGNER_ROLE, _signers[i]);\n        }\n        \n        // Set admin role\n        _grantRole(ADMIN_ROLE, msg.sender);\n    }\n    \n    /**\n     * @notice Submit a transaction for approval\n     * @param to Destination address\n     * @param value ETH value to send\n     * @param data Call data\n     * @return txId Transaction ID\n     */\n    function submitTransaction(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external onlyRole(SIGNER_ROLE) returns (uint256 txId) {\n        txId = nonce++;\n        \n        Transaction storage transaction = transactions[txId];\n        transaction.to = to;\n        transaction.value = value;\n        transaction.data = data;\n        transaction.executed = false;\n        transaction.confirmations = 0;\n        \n        // Auto-confirm by submitter\n        transaction.confirmed[msg.sender] = true;\n        transaction.confirmations = 1;\n        \n        emit TransactionSubmitted(txId, to, value, data);\n        emit TransactionConfirmed(txId, msg.sender);\n    }\n    \n    /**\n     * @notice Confirm a transaction\n     * @param txId Transaction ID\n     */\n    function confirmTransaction(uint256 txId) external onlyRole(SIGNER_ROLE) {\n        Transaction storage transaction = transactions[txId];\n        \n        if (transaction.executed) revert TransactionAlreadyExecuted();\n        if (transaction.confirmed[msg.sender]) revert AlreadyConfirmed();\n        \n        transaction.confirmed[msg.sender] = true;\n        transaction.confirmations++;\n        \n        emit TransactionConfirmed(txId, msg.sender);\n    }\n    \n    /**\n     * @notice Execute a confirmed transaction\n     * @param txId Transaction ID\n     */\n    function executeTransaction(uint256 txId) external {\n        Transaction storage transaction = transactions[txId];\n        \n        if (transaction.executed) revert TransactionAlreadyExecuted();\n        if (transaction.confirmations < requiredSignatures) revert InsufficientSignatures();\n        \n        transaction.executed = true;\n        \n        (bool success, bytes memory returnData) = transaction.to.call{value: transaction.value}(transaction.data);\n        \n        if (!success) {\n            revert TransactionFailed();\n        }\n        \n        emit TransactionExecuted(txId, success, returnData);\n    }\n    \n    /**\n     * @notice Add a new signer\n     * @param signer Address of the new signer\n     */\n    function addSigner(address signer) external onlyRole(ADMIN_ROLE) {\n        if (signer == address(0)) revert InvalidSigner();\n        \n        signers.push(signer);\n        _grantRole(SIGNER_ROLE, signer);\n        \n        emit SignerAdded(signer);\n    }\n    \n    /**\n     * @notice Remove a signer\n     * @param signer Address of the signer to remove\n     */\n    function removeSigner(address signer) external onlyRole(ADMIN_ROLE) {\n        if (!hasRole(SIGNER_ROLE, signer)) revert InvalidSigner();\n        \n        // Remove from array\n        for (uint256 i = 0; i < signers.length; i++) {\n            if (signers[i] == signer) {\n                signers[i] = signers[signers.length - 1];\n                signers.pop();\n                break;\n            }\n        }\n        \n        _revokeRole(SIGNER_ROLE, signer);\n        \n        emit SignerRemoved(signer);\n    }\n    \n    /**\n     * @notice Update required signatures\n     * @param _requiredSignatures New required signatures count\n     */\n    function updateRequiredSignatures(uint256 _requiredSignatures) external onlyRole(ADMIN_ROLE) {\n        if (_requiredSignatures == 0 || _requiredSignatures > signers.length) {\n            revert InvalidRequiredSignatures();\n        }\n        \n        uint256 oldRequired = requiredSignatures;\n        requiredSignatures = _requiredSignatures;\n        \n        emit RequiredSignaturesUpdated(oldRequired, _requiredSignatures);\n    }\n    \n    // ============ View Functions ============\n    \n    /**\n     * @notice Get all signers\n     * @return Array of signer addresses\n     */\n    function getSigners() external view returns (address[] memory) {\n        return signers;\n    }\n    \n    /**\n     * @notice Get signer count\n     * @return Number of signers\n     */\n    function getSignerCount() external view returns (uint256) {\n        return signers.length;\n    }\n    \n    /**\n     * @notice Check if address is a signer\n     * @param signer Address to check\n     * @return isSigner Whether address is a signer\n     */\n    function isSigner(address signer) external view returns (bool) {\n        return hasRole(SIGNER_ROLE, signer);\n    }\n    \n    /**\n     * @notice Get transaction details\n     * @param txId Transaction ID\n     * @return to Destination address\n     * @return value ETH value\n     * @return data Call data\n     * @return executed Whether executed\n     * @return confirmations Number of confirmations\n     */\n    function getTransaction(uint256 txId) external view returns (\n        address to,\n        uint256 value,\n        bytes memory data,\n        bool executed,\n        uint256 confirmations\n    ) {\n        Transaction storage transaction = transactions[txId];\n        return (transaction.to, transaction.value, transaction.data, transaction.executed, transaction.confirmations);\n    }\n    \n    /**\n     * @notice Check if signer has confirmed transaction\n     * @param txId Transaction ID\n     * @param signer Signer address\n     * @return confirmed Whether confirmed\n     */\n    function isConfirmed(uint256 txId, address signer) external view returns (bool confirmed) {\n        Transaction storage transaction = transactions[txId];\n        return transaction.confirmed[signer];\n    }\n    \n    /**\n     * @notice Check if transaction can be executed\n     * @param txId Transaction ID\n     * @return canExecute Whether can execute\n     */\n    function canExecute(uint256 txId) external view returns (bool) {\n        Transaction storage transaction = transactions[txId];\n        return !transaction.executed && transaction.confirmations >= requiredSignatures;\n    }\n    \n    // ============ Receive Function ============\n    receive() external payable {}\n}\n"
    },
    "contracts/mock/MockVestingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title MockVestingContract\n * @notice Mock contract for testing vesting functionality\n * @dev This is a simple mock that implements basic ERC20 functionality for testing\n */\ncontract MockVestingContract is Initializable, OwnableUpgradeable {\n    \n    string public name;\n    string public symbol;\n    \n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowances;\n    \n    uint256 public totalSupply;\n    \n    // ============ Events ============\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    \n    /**\n     * @notice Initialize the mock vesting contract\n     * @param _name Contract name\n     * @param _symbol Contract symbol\n     */\n    function initialize(string memory _name, string memory _symbol) public initializer {\n        __Ownable_init(msg.sender);\n        name = _name;\n        symbol = _symbol;\n    }\n    \n    /**\n     * @notice Mock transfer function for testing\n     * @param to Recipient address\n     * @param amount Amount to transfer\n     * @return success Success status\n     */\n    function transfer(address to, uint256 amount) external returns (bool success) {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        \n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n        \n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    \n    /**\n     * @notice Mock transferFrom function for testing\n     * @param from Sender address\n     * @param to Recipient address\n     * @param amount Amount to transfer\n     * @return success Success status\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool success) {\n        require(balances[from] >= amount, \"Insufficient balance\");\n        require(allowances[from][msg.sender] >= amount, \"Insufficient allowance\");\n        \n        balances[from] -= amount;\n        balances[to] += amount;\n        allowances[from][msg.sender] -= amount;\n        \n        emit Transfer(from, to, amount);\n        return true;\n    }\n    \n    /**\n     * @notice Mock approve function for testing\n     * @param spender Spender address\n     * @param amount Amount to approve\n     * @return success Success status\n     */\n    function approve(address spender, uint256 amount) external returns (bool success) {\n        allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    \n    /**\n     * @notice Get balance of an address\n     * @param account Account address\n     * @return balance Balance amount\n     */\n    function balanceOf(address account) external view returns (uint256 balance) {\n        return balances[account];\n    }\n    \n    /**\n     * @notice Get allowance\n     * @param owner Owner address\n     * @param spender Spender address\n     * @return allowance Allowance amount\n     */\n    function allowance(address owner, address spender) external view returns (uint256 allowance) {\n        return allowances[owner][spender];\n    }\n    \n    /**\n     * @notice Mint tokens (for testing purposes)\n     * @param to Recipient address\n     * @param amount Amount to mint\n     */\n    function mint(address to, uint256 amount) external onlyOwner {\n        balances[to] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), to, amount);\n    }\n    \n    /**\n     * @notice Burn tokens (for testing purposes)\n     * @param from Address to burn from\n     * @param amount Amount to burn\n     */\n    function burn(address from, uint256 amount) external onlyOwner {\n        require(balances[from] >= amount, \"Insufficient balance\");\n        balances[from] -= amount;\n        totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/proxy/HyraProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"../interfaces/IHyraProxyAdmin.sol\";\n\n/**\n * @title HyraProxyAdmin\n * @notice Extended ProxyAdmin for managing Hyra protocol proxies\n * @dev SECURITY WARNING: This contract has upgrade authority over all protocol contracts.\n *      Ownership should be transferred to a multisig wallet or timelock contract.\n *      See: https://docs.hyra.network/security for more information.\n */\ncontract HyraProxyAdmin is ProxyAdmin, IHyraProxyAdmin {\n    // ============ State Variables ============\n    mapping(address => bool) private _isManaged;\n    address[] public managedProxies;\n    mapping(address => string) public proxyNames;\n    \n    // ============ Events ============\n    event ProxyAdded(address indexed proxy, string name);\n    event ProxyRemoved(address indexed proxy);\n    event ProxyNameUpdated(address indexed proxy, string newName);\n    event BatchUpgradeExecuted(uint256 count);\n    \n    // ============ Errors ============\n    error ProxyAlreadyManaged();\n    error ProxyNotManaged();\n    error InvalidProxy();\n    error InvalidProxyAddress();\n    error ZeroAddress();\n    error ArrayLengthMismatch();\n    error IndexOutOfBounds();\n\n    /**\n     * @notice Constructor\n     * @param initialOwner The initial owner of the ProxyAdmin\n     */\n    constructor(address initialOwner) ProxyAdmin(initialOwner) {}\n\n    // ============ Management Functions ============\n\n    /**\n     * @notice Add a proxy to management with a name\n     * @param proxy Address of the proxy to manage\n     * @param name Human-readable name for the proxy\n     */\n    function addProxy(address proxy, string memory name) \n        external \n        override\n        onlyOwner \n    {\n        if (proxy == address(0)) revert ZeroAddress();\n        if (_isManaged[proxy]) revert ProxyAlreadyManaged();\n        \n        _isManaged[proxy] = true;\n        managedProxies.push(proxy);\n        proxyNames[proxy] = name;\n        \n        emit ProxyAdded(proxy, name);\n    }\n\n    /**\n     * @notice Remove a proxy from management\n     * @param proxy Address of the proxy to remove\n     */\n    function removeProxy(address proxy) external override onlyOwner {\n        if (!_isManaged[proxy]) revert ProxyNotManaged();\n        \n        _isManaged[proxy] = false;\n        delete proxyNames[proxy];\n        \n        // Remove from array\n        for (uint256 i = 0; i < managedProxies.length; i++) {\n            if (managedProxies[i] == proxy) {\n                managedProxies[i] = managedProxies[managedProxies.length - 1];\n                managedProxies.pop();\n                break;\n            }\n        }\n        \n        emit ProxyRemoved(proxy);\n    }\n\n    /**\n     * @notice Update the name of a managed proxy\n     * @param proxy Address of the proxy\n     * @param newName New name for the proxy\n     */\n    function updateProxyName(address proxy, string memory newName) \n        external \n        onlyOwner \n    {\n        if (!_isManaged[proxy]) revert ProxyNotManaged();\n        proxyNames[proxy] = newName;\n        emit ProxyNameUpdated(proxy, newName);\n    }\n\n    /**\n     * @notice Batch upgrade multiple proxies\n     * @param proxies Array of proxy addresses\n     * @param implementations Array of new implementation addresses\n     */\n    function batchUpgrade(\n        address[] calldata proxies,\n        address[] calldata implementations\n    ) external override onlyOwner {\n        if (proxies.length != implementations.length) revert ArrayLengthMismatch();\n        \n        for (uint256 i = 0; i < proxies.length; i++) {\n            if (!_isManaged[proxies[i]]) revert ProxyNotManaged();\n            \n            // Use the ProxyAdmin's upgradeAndCall function\n            ITransparentUpgradeableProxy proxy = ITransparentUpgradeableProxy(payable(proxies[i]));\n            upgradeAndCall(proxy, implementations[i], bytes(\"\"));\n        }\n        \n        emit BatchUpgradeExecuted(proxies.length);\n    }\n\n    /**\n     * @notice Batch upgrade with initialization calls\n     * @param proxies Array of proxy addresses\n     * @param implementations Array of new implementation addresses\n     * @param datas Array of initialization call data\n     */\n    function batchUpgradeAndCall(\n        address[] calldata proxies,\n        address[] calldata implementations,\n        bytes[] calldata datas\n    ) external onlyOwner {\n        if (proxies.length != implementations.length || \n            proxies.length != datas.length) {\n            revert ArrayLengthMismatch();\n        }\n        \n        for (uint256 i = 0; i < proxies.length; i++) {\n            if (!_isManaged[proxies[i]]) revert ProxyNotManaged();\n            \n            ITransparentUpgradeableProxy proxy = ITransparentUpgradeableProxy(payable(proxies[i]));\n            upgradeAndCall(proxy, implementations[i], datas[i]);\n        }\n        \n        emit BatchUpgradeExecuted(proxies.length);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get all managed proxies\n     * @return Array of managed proxy addresses\n     */\n    function getManagedProxies() external view override returns (address[] memory) {\n        return managedProxies;\n    }\n\n    /**\n     * @notice Get the count of managed proxies\n     * @return Number of managed proxies\n     */\n    function getManagedProxyCount() external view returns (uint256) {\n        return managedProxies.length;\n    }\n\n    /**\n     * @notice Get proxy info by index\n     * @param index Index in the managed proxies array\n     * @return proxy address and name\n     */\n    function getProxyByIndex(uint256 index) \n        external \n        view \n        returns (address proxy, string memory name) \n    {\n        if (index >= managedProxies.length) revert IndexOutOfBounds();\n        proxy = managedProxies[index];\n        name = proxyNames[proxy];\n    }\n\n    /**\n     * @notice Check if a proxy is managed\n     * @param proxy Address to check\n     * @return True if the proxy is managed\n     */\n    function isManaged(address proxy) external view override returns (bool) {\n        return _isManaged[proxy];\n    }\n\n    /**\n     * @notice Get implementation address of a proxy\n     * @dev Uses low-level call to get implementation\n     * @param proxyAddress The proxy address\n     * @return impl The implementation address\n     */\n    function getProxyImplementation(address proxyAddress) \n        external \n        view \n        returns (address impl) \n    {\n        if (proxyAddress == address(0)) revert InvalidProxyAddress();\n        \n        // Use low-level staticcall to get implementation\n        // This avoids interface issues\n        bytes memory data = abi.encodeWithSignature(\"implementation()\");\n        (bool success, bytes memory returnData) = proxyAddress.staticcall(data);\n        \n        if (success && returnData.length == 32) {\n            impl = abi.decode(returnData, (address));\n        } else {\n            impl = address(0);\n        }\n    }\n\n    /**\n     * @notice Get admin of a proxy\n     * @dev Returns this contract if we manage the proxy\n     * @param proxy The proxy address\n     * @return The admin address\n     */\n    function getProxyAdmin(address proxy) \n        external \n        view \n        returns (address) \n    {\n        // If we manage this proxy, we are the admin\n        return _isManaged[proxy] ? address(this) : address(0);\n    }\n}"
    },
    "contracts/proxy/HyraProxyDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"./HyraTransparentUpgradeableProxy.sol\";\nimport \"../interfaces/IHyraProxyDeployer.sol\";\n\n/**\n * @title HyraProxyDeployer\n * @notice Factory contract for deploying Hyra protocol proxies\n */\ncontract HyraProxyDeployer is IHyraProxyDeployer {\n    // ============ Structs ============\n    struct ProxyInfo {\n        address implementation;\n        address proxyAdmin;\n        string contractType;\n        uint256 deploymentTime;\n        address deployer;\n        uint256 nonce;\n        bytes32 salt; // For deterministic deployments\n    }\n    \n    // ============ State Variables ============\n    mapping(address => ProxyInfo) public deployedProxies;\n    address[] public allProxies;\n    uint256 public deploymentNonce;\n    \n    // ============ Events ============\n    event ProxyDeployed(\n        address indexed proxy,\n        address indexed implementation,\n        address indexed proxyAdmin,\n        string contractType,\n        uint256 nonce\n    );\n    \n    event DeterministicProxyDeployed(\n        address indexed proxy,\n        address indexed implementation,\n        address indexed proxyAdmin,\n        bytes32 salt\n    );\n    \n    // ============ Errors ============\n    error InvalidImplementation();\n    error InvalidAdmin();\n    error DeploymentFailed();\n    error ProxyAlreadyDeployed();\n    error ZeroAddress();\n    error InvalidContractType();\n    error InvalidProxy();\n\n    /**\n     * @notice Deploy a new TransparentUpgradeableProxy\n     * @param implementation Initial implementation contract\n     * @param proxyAdmin Address of the ProxyAdmin contract\n     * @param initData Initialization data\n     * @param contractType Type identifier for the contract\n     * @return proxy Address of the deployed proxy\n     */\n    function deployProxy(\n        address implementation,\n        address proxyAdmin,\n        bytes memory initData,\n        string memory contractType\n    ) external override returns (address proxy) {\n        if (implementation == address(0)) revert InvalidImplementation();\n        if (proxyAdmin == address(0)) revert InvalidAdmin();\n        if (bytes(contractType).length == 0) revert InvalidContractType();\n        \n        // FIXED: Apply Checks-Effects-Interactions pattern\n        // 1. Pre-calculate values to avoid reentrancy\n        uint256 currentNonce = deploymentNonce;\n        address currentDeployer = tx.origin;\n        uint256 currentTimestamp = block.timestamp;\n        \n        // 2. Make external call (Interactions)\n        proxy = address(\n            new HyraTransparentUpgradeableProxy(\n                implementation,\n                proxyAdmin,\n                initData\n            )\n        );\n        \n        if (proxy == address(0)) revert DeploymentFailed();\n        \n        // 3. Update state after external call (Effects)\n        deployedProxies[proxy] = ProxyInfo({\n            implementation: implementation,\n            proxyAdmin: proxyAdmin,\n            contractType: contractType,\n            deploymentTime: currentTimestamp,\n            deployer: currentDeployer,\n            nonce: currentNonce,\n            salt: bytes32(0) // Not deterministic\n        });\n        \n        allProxies.push(proxy);\n        deploymentNonce++;\n        \n        emit ProxyDeployed(\n            proxy,\n            implementation,\n            proxyAdmin,\n            contractType,\n            currentNonce\n        );\n    }\n\n    /**\n     * @notice Deploy proxy with CREATE2 for deterministic addresses\n     * @param implementation Implementation address\n     * @param proxyAdmin ProxyAdmin address\n     * @param initData Initialization data\n     * @param salt Salt for CREATE2\n     * @param contractType Type identifier for the contract\n     * @return proxy Address of the deployed proxy\n     */\n    function deployProxyDeterministic(\n        address implementation,\n        address proxyAdmin,\n        bytes memory initData,\n        bytes32 salt,\n        string memory contractType\n    ) external returns (address proxy) {\n        // Generate unique salt to prevent frontrunning\n        bytes32 uniqueSalt = keccak256(abi.encodePacked(salt, msg.sender, block.timestamp));\n        if (implementation == address(0)) revert InvalidImplementation();\n        if (proxyAdmin == address(0)) revert InvalidAdmin();\n        if (bytes(contractType).length == 0) revert InvalidContractType();\n        \n        // Create bytecode for CREATE2\n        bytes memory bytecode = abi.encodePacked(\n            type(HyraTransparentUpgradeableProxy).creationCode,\n            abi.encode(implementation, proxyAdmin, initData)\n        );\n        \n        // Deploy with CREATE2 using unique salt\n        assembly {\n            proxy := create2(0, add(bytecode, 0x20), mload(bytecode), uniqueSalt)\n        }\n        \n        if (proxy == address(0)) revert DeploymentFailed();\n        if (deployedProxies[proxy].deploymentTime != 0) revert ProxyAlreadyDeployed();\n        \n        // Store proxy info\n        deployedProxies[proxy] = ProxyInfo({\n            implementation: implementation,\n            proxyAdmin: proxyAdmin,\n            contractType: contractType,\n            deploymentTime: block.timestamp,\n            deployer: tx.origin, // Use tx.origin for actual deployer\n            nonce: deploymentNonce,\n            salt: salt\n        });\n        \n        allProxies.push(proxy);\n        deploymentNonce++;\n        \n        emit DeterministicProxyDeployed(\n            proxy,\n            implementation,\n            proxyAdmin,\n            salt\n        );\n    }\n\n    /**\n     * @notice Compute the deployment address for CREATE2\n     * @param implementation Implementation address\n     * @param proxyAdmin ProxyAdmin address\n     * @param initData Initialization data\n     * @param salt Salt for CREATE2\n     * @return computedAddress The computed proxy address\n     */\n    function computeProxyAddress(\n        address implementation,\n        address proxyAdmin,\n        bytes memory initData,\n        bytes32 salt\n    ) external view returns (address computedAddress) {\n        bytes memory bytecode = abi.encodePacked(\n            type(HyraTransparentUpgradeableProxy).creationCode,\n            abi.encode(implementation, proxyAdmin, initData)\n        );\n        \n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(bytecode)\n            )\n        );\n        \n        computedAddress = address(uint160(uint256(hash)));\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get all deployed proxies\n     * @return Array of proxy addresses\n     */\n    function getAllProxies() external view returns (address[] memory) {\n        return allProxies;\n    }\n\n    /**\n     * @notice Get proxy count\n     * @return Number of deployed proxies\n     */\n    function getProxyCount() external view returns (uint256) {\n        return allProxies.length;\n    }\n\n    /**\n     * @notice Check if an address is a deployed proxy\n     * @param proxy Address to check\n     * @return True if the address is a deployed proxy\n     */\n    function isDeployedProxy(address proxy) external view override returns (bool) {\n        return deployedProxies[proxy].deploymentTime != 0;\n    }\n\n    /**\n     * @notice Get detailed proxy information\n     * @param proxy Address of the proxy\n     * @return info ProxyInfo struct with all details\n     */\n    function getProxyInfo(address proxy) external view returns (ProxyInfo memory info) {\n        info = deployedProxies[proxy];\n        if (info.deploymentTime == 0) revert InvalidProxy();\n        return info;\n    }\n\n    /**\n     * @notice Get proxies by type\n     * @param contractType Type of contract to filter by\n     * @return proxies Array of proxy addresses of the given type\n     */\n    function getProxiesByType(string memory contractType) \n        external \n        view \n        returns (address[] memory proxies) \n    {\n        uint256 length = allProxies.length;\n        uint256 count = 0;\n        \n        // Count matching proxies\n        for (uint256 i = 0; i < length; i++) {\n            if (keccak256(bytes(deployedProxies[allProxies[i]].contractType)) == \n                keccak256(bytes(contractType))) {\n                count++;\n            }\n        }\n        \n        // Collect matching proxies\n        proxies = new address[](count);\n        uint256 index = 0;\n        \n        for (uint256 i = 0; i < length; i++) {\n            if (keccak256(bytes(deployedProxies[allProxies[i]].contractType)) == \n                keccak256(bytes(contractType))) {\n                proxies[index++] = allProxies[i];\n            }\n        }\n    }\n\n    /**\n     * @notice Get proxies deployed by a specific address\n     * @param deployer Address of the deployer\n     * @return proxies Array of proxy addresses deployed by the deployer\n     */\n    function getProxiesByDeployer(address deployer) \n        external \n        view \n        returns (address[] memory proxies) \n    {\n        uint256 length = allProxies.length;\n        uint256 count = 0;\n        \n        // Count matching proxies\n        for (uint256 i = 0; i < length; i++) {\n            if (deployedProxies[allProxies[i]].deployer == deployer) {\n                count++;\n            }\n        }\n        \n        // Collect matching proxies\n        proxies = new address[](count);\n        uint256 index = 0;\n        \n        for (uint256 i = 0; i < length; i++) {\n            if (deployedProxies[allProxies[i]].deployer == deployer) {\n                proxies[index++] = allProxies[i];\n            }\n        }\n    }\n}"
    },
    "contracts/proxy/HyraTransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC1967.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title HyraTransparentUpgradeableProxy\n * @dev Custom proxy that is compatible with HyraProxyAdmin\n *      Inherits from ERC1967Proxy instead of TransparentUpgradeableProxy\n *      to avoid auto-creation of ProxyAdmin in OZ v5.4+\n */\ncontract HyraTransparentUpgradeableProxy is ERC1967Proxy {\n    \n\n    /**\n     * @dev Throws if called by any account other than the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == bytes4(keccak256(\"upgradeToAndCall(address,bytes)\"))) {\n                ret = _dispatchUpgradeToAndCall();\n            } else {\n                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view virtual returns (address) {\n        return ERC1967Utils.getAdmin();\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert(\"TransparentUpgradeableProxy: new admin is the zero address\");\n        }\n        ERC1967Utils.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal virtual {\n        emit IERC1967.AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        return \"\";\n    }\n\n    /**\n     * @dev Constructor\n     * @param _logic Address of the initial implementation.\n     * @param admin_ Address of the proxy admin.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     * @return implementation The current implementation address\n     */\n    function implementation() public view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Returns the current admin address.\n     * @return admin The current admin address\n     */\n    function admin() public view returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        ERC1967Utils.upgradeToAndCall(newImplementation, data);\n    }\n}\n\n"
    },
    "contracts/proxy/SecureProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title SecureProxyAdmin\n * @notice Enhanced ProxyAdmin with multi-signature and governance controls for HNA-02 fix\n * @dev Implements security recommendations:\n *      - Multi-signature wallet integration\n *      - Time-lock delays for community awareness\n *      - Transparent upgrade process\n */\ncontract SecureProxyAdmin is ProxyAdmin, AccessControl {\n    // ============ Constants ============\n    bytes32 public constant MULTISIG_ROLE = keccak256(\"MULTISIG_ROLE\");\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n    \n    uint256 public constant UPGRADE_DELAY = 48 hours; // 48 hour delay for community awareness\n    uint256 public constant EMERGENCY_DELAY = 2 hours; // 2 hour delay for emergency upgrades\n    \n    // ============ State Variables ============\n    mapping(address => bool) private _isManaged;\n    address[] public managedProxies;\n    mapping(address => string) public proxyNames;\n    \n    // Upgrade tracking\n    struct PendingUpgrade {\n        address implementation;\n        uint256 executeTime;\n        bool isEmergency;\n        string reason;\n        address proposer;\n    }\n    \n    mapping(address => PendingUpgrade) public pendingUpgrades;\n    mapping(bytes32 => bool) public executedUpgrades;\n    uint256 public upgradeNonce;\n    \n    // Multi-signature requirements\n    uint256 public requiredSignatures;\n    mapping(bytes32 => mapping(address => bool)) public signatures;\n    mapping(bytes32 => uint256) public signatureCount;\n    \n    // ============ Events ============\n    event ProxyAdded(address indexed proxy, string name);\n    event ProxyRemoved(address indexed proxy);\n    event ProxyNameUpdated(address indexed proxy, string newName);\n    event BatchUpgradeExecuted(uint256 count);\n    \n    event UpgradeProposed(\n        address indexed proxy,\n        address indexed implementation,\n        uint256 executeTime,\n        bool isEmergency,\n        string reason,\n        bytes32 upgradeId\n    );\n    \n    event UpgradeExecuted(\n        address indexed proxy,\n        address indexed implementation,\n        bytes32 upgradeId\n    );\n    \n    event UpgradeCancelled(\n        address indexed proxy,\n        bytes32 upgradeId\n    );\n    \n    event SignatureAdded(\n        bytes32 indexed upgradeId,\n        address indexed signer,\n        uint256 signatureCount,\n        uint256 requiredSignatures\n    );\n    \n    // ============ Errors ============\n    error ProxyAlreadyManaged();\n    error ProxyNotManaged();\n    error InvalidProxy();\n    error InvalidProxyAddress();\n    error ZeroAddress();\n    error ArrayLengthMismatch();\n    error IndexOutOfBounds();\n    error UpgradeAlreadyScheduled();\n    error NoUpgradeScheduled();\n    error UpgradeNotReady();\n    error UpgradeExpired();\n    error UpgradeAlreadyExecuted();\n    error InsufficientSignatures();\n    error AlreadySigned();\n    error InvalidDelay();\n    error UnauthorizedUpgrade();\n    error InvalidImplementation();\n\n    /**\n     * @notice Constructor\n     * @param initialOwner The initial owner (should be multisig wallet)\n     * @param _requiredSignatures Number of signatures required for upgrades\n     */\n    constructor(address initialOwner, uint256 _requiredSignatures) ProxyAdmin(initialOwner) {\n        if (initialOwner == address(0)) revert ZeroAddress();\n        if (_requiredSignatures == 0) revert InvalidDelay();\n        \n        requiredSignatures = _requiredSignatures;\n        \n        // Grant roles\n        _grantRole(DEFAULT_ADMIN_ROLE, initialOwner);\n        _grantRole(MULTISIG_ROLE, initialOwner);\n        _grantRole(GOVERNANCE_ROLE, initialOwner);\n        _grantRole(EMERGENCY_ROLE, initialOwner);\n    }\n\n    // ============ Management Functions ============\n\n    /**\n     * @notice Add a proxy to management with a name\n     * @param proxy Address of the proxy to manage\n     * @param name Human-readable name for the proxy\n     */\n    function addProxy(address proxy, string memory name) \n        external \n        onlyRole(MULTISIG_ROLE)\n    {\n        if (proxy == address(0)) revert InvalidProxyAddress();\n        if (_isManaged[proxy]) revert ProxyAlreadyManaged();\n        \n        _isManaged[proxy] = true;\n        managedProxies.push(proxy);\n        proxyNames[proxy] = name;\n        \n        emit ProxyAdded(proxy, name);\n    }\n\n    /**\n     * @notice Remove a proxy from management\n     * @param proxy Address of the proxy to remove\n     */\n    function removeProxy(address proxy) external onlyRole(MULTISIG_ROLE) {\n        if (!_isManaged[proxy]) revert ProxyNotManaged();\n        \n        _isManaged[proxy] = false;\n        delete proxyNames[proxy];\n        \n        // Remove from array\n        for (uint256 i = 0; i < managedProxies.length; i++) {\n            if (managedProxies[i] == proxy) {\n                managedProxies[i] = managedProxies[managedProxies.length - 1];\n                managedProxies.pop();\n                break;\n            }\n        }\n        \n        emit ProxyRemoved(proxy);\n    }\n\n    /**\n     * @notice Update the name of a managed proxy\n     * @param proxy Address of the proxy\n     * @param newName New name for the proxy\n     */\n    function updateProxyName(address proxy, string memory newName) \n        external \n        onlyRole(MULTISIG_ROLE)\n    {\n        if (!_isManaged[proxy]) revert ProxyNotManaged();\n        proxyNames[proxy] = newName;\n        emit ProxyNameUpdated(proxy, newName);\n    }\n\n    // ============ Upgrade Functions ============\n\n    /**\n     * @notice Propose an upgrade with multi-signature requirement\n     * @param proxy Address of the proxy to upgrade\n     * @param implementation Address of the new implementation\n     * @param isEmergency Whether this is an emergency upgrade\n     * @param reason Reason for the upgrade\n     */\n    function proposeUpgrade(\n        address proxy,\n        address implementation,\n        bool isEmergency,\n        string memory reason\n    ) external onlyRole(GOVERNANCE_ROLE) {\n        if (proxy == address(0)) revert InvalidProxy();\n        if (implementation == address(0)) revert InvalidImplementation();\n        if (!_isManaged[proxy]) revert ProxyNotManaged();\n        \n        // Check if there's already a pending upgrade\n        if (pendingUpgrades[proxy].executeTime != 0) {\n            if (block.timestamp > pendingUpgrades[proxy].executeTime + 48 hours) {\n                // Clear expired upgrade\n                delete pendingUpgrades[proxy];\n            } else {\n                revert UpgradeAlreadyScheduled();\n            }\n        }\n        \n        uint256 delay = isEmergency ? EMERGENCY_DELAY : UPGRADE_DELAY;\n        uint256 executeTime = block.timestamp + delay;\n        \n        pendingUpgrades[proxy] = PendingUpgrade({\n            implementation: implementation,\n            executeTime: executeTime,\n            isEmergency: isEmergency,\n            reason: reason,\n            proposer: msg.sender\n        });\n        \n        uint256 nonce = ++upgradeNonce;\n        bytes32 upgradeId = keccak256(\n            abi.encodePacked(proxy, implementation, nonce, block.timestamp)\n        );\n        \n        emit UpgradeProposed(proxy, implementation, executeTime, isEmergency, reason, upgradeId);\n    }\n\n    /**\n     * @notice Sign an upgrade proposal\n     * @param upgradeId The upgrade proposal ID\n     */\n    function signUpgrade(bytes32 upgradeId) external onlyRole(MULTISIG_ROLE) {\n        if (signatures[upgradeId][msg.sender]) revert AlreadySigned();\n        \n        signatures[upgradeId][msg.sender] = true;\n        signatureCount[upgradeId]++;\n        \n        emit SignatureAdded(upgradeId, msg.sender, signatureCount[upgradeId], requiredSignatures);\n    }\n\n    /**\n     * @notice Execute an upgrade after sufficient signatures and delay\n     * @param proxy Address of the proxy to upgrade\n     */\n    function executeUpgrade(address proxy) external {\n        PendingUpgrade memory upgrade = pendingUpgrades[proxy];\n        if (upgrade.executeTime == 0) revert NoUpgradeScheduled();\n        if (block.timestamp < upgrade.executeTime) revert UpgradeNotReady();\n        \n        // Check if upgrade hasn't expired (48 hour window)\n        if (block.timestamp > upgrade.executeTime + 48 hours) {\n            revert UpgradeExpired();\n        }\n        \n        uint256 nonce = upgradeNonce;\n        bytes32 upgradeId = keccak256(\n            abi.encodePacked(proxy, upgrade.implementation, nonce, upgrade.executeTime - (upgrade.isEmergency ? EMERGENCY_DELAY : UPGRADE_DELAY))\n        );\n        \n        if (executedUpgrades[upgradeId]) revert UpgradeAlreadyExecuted();\n        \n        // Check signature requirements\n        if (signatureCount[upgradeId] < requiredSignatures) {\n            revert InsufficientSignatures();\n        }\n        \n        // FIXED: Apply Checks-Effects-Interactions pattern\n        // 1. Update state first (Effects)\n        executedUpgrades[upgradeId] = true;\n        delete pendingUpgrades[proxy];\n        \n        // 2. Then make external calls (Interactions)\n        // Call proxy's admin function directly as this contract is the admin\n        ITransparentUpgradeableProxy(payable(proxy)).upgradeToAndCall(upgrade.implementation, bytes(\"\"));\n        \n        emit UpgradeExecuted(proxy, upgrade.implementation, upgradeId);\n    }\n\n    /**\n     * @notice Cancel a pending upgrade\n     * @param proxy Address of the proxy\n     */\n    function cancelUpgrade(address proxy) external onlyRole(MULTISIG_ROLE) {\n        PendingUpgrade memory upgrade = pendingUpgrades[proxy];\n        if (upgrade.executeTime == 0) revert NoUpgradeScheduled();\n\n        uint256 nonce = upgradeNonce;\n        bytes32 upgradeId = keccak256(\n            abi.encodePacked(proxy, upgrade.implementation, nonce, upgrade.executeTime - (upgrade.isEmergency ? EMERGENCY_DELAY : UPGRADE_DELAY))\n        );\n        \n        delete pendingUpgrades[proxy];\n        emit UpgradeCancelled(proxy, upgradeId);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get all managed proxies\n     * @return Array of managed proxy addresses\n     */\n    function getManagedProxies() external view returns (address[] memory) {\n        return managedProxies;\n    }\n\n    /**\n     * @notice Get the count of managed proxies\n     * @return Number of managed proxies\n     */\n    function getManagedProxyCount() external view returns (uint256) {\n        return managedProxies.length;\n    }\n\n    /**\n     * @notice Get proxy info by index\n     * @param index Index in the managed proxies array\n     * @return proxy address and name\n     */\n    function getProxyByIndex(uint256 index) \n        external \n        view \n        returns (address proxy, string memory name) \n    {\n        if (index >= managedProxies.length) revert IndexOutOfBounds();\n        proxy = managedProxies[index];\n        name = proxyNames[proxy];\n    }\n\n    /**\n     * @notice Get pending upgrade information\n     * @param proxy Address of the proxy\n     * @return upgrade Pending upgrade details\n     */\n    function getPendingUpgrade(address proxy) external view returns (PendingUpgrade memory upgrade) {\n        return pendingUpgrades[proxy];\n    }\n\n    /**\n     * @notice Check if upgrade can be executed\n     * @param proxy Address of the proxy\n     * @return canExecute Whether upgrade can be executed\n     * @return reason Reason if cannot execute\n     */\n    function canExecuteUpgrade(address proxy) external view returns (bool canExecute, string memory reason) {\n        PendingUpgrade memory upgrade = pendingUpgrades[proxy];\n        \n        if (upgrade.executeTime == 0) {\n            return (false, \"No upgrade scheduled\");\n        }\n        \n        if (block.timestamp < upgrade.executeTime) {\n            return (false, \"Upgrade not ready\");\n        }\n        \n        if (block.timestamp > upgrade.executeTime + 48 hours) {\n            return (false, \"Upgrade expired\");\n        }\n        \n        uint256 nonce = upgradeNonce;\n        bytes32 upgradeId = keccak256(\n            abi.encodePacked(proxy, upgrade.implementation, nonce, upgrade.executeTime - (upgrade.isEmergency ? EMERGENCY_DELAY : UPGRADE_DELAY))\n        );\n        \n        if (signatureCount[upgradeId] < requiredSignatures) {\n            return (false, \"Insufficient signatures\");\n        }\n        \n        return (true, \"Upgrade ready to execute\");\n    }\n\n    /**\n     * @notice Get signature count for an upgrade\n     * @param upgradeId The upgrade proposal ID\n     * @return count Number of signatures\n     */\n    function getSignatureCount(bytes32 upgradeId) external view returns (uint256 count) {\n        return signatureCount[upgradeId];\n    }\n\n    /**\n     * @notice Check if an address has signed an upgrade\n     * @param upgradeId The upgrade proposal ID\n     * @param signer Address to check\n     * @return Whether the address has signed\n     */\n    function hasSigned(bytes32 upgradeId, address signer) external view returns (bool) {\n        return signatures[upgradeId][signer];\n    }\n\n    /**\n     * @notice Check if proxy is managed\n     * @param proxy Address of the proxy\n     * @return Whether proxy is managed\n     */\n    function isManaged(address proxy) external view returns (bool) {\n        return _isManaged[proxy];\n    }\n}\n"
    },
    "contracts/security/DAORoleManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\n\n/**\n * @title DAORoleManager\n * @notice Decentralized role management system that replaces centralized governance roles\n * @dev Implements DAO-governed role management to eliminate centralization risks\n */\ncontract DAORoleManager is Initializable, AccessControlUpgradeable {\n    // ============ Constants ============\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n    bytes32 public constant SECURITY_COUNCIL_ROLE = keccak256(\"SECURITY_COUNCIL_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    \n    // ============ State Variables ============\n    IVotes public governanceToken;\n    GovernorUpgradeable public governor;\n    TimelockControllerUpgradeable public timelock;\n    \n    // Role management tracking\n    mapping(bytes32 => mapping(address => bool)) public roleRequests;\n    mapping(bytes32 => mapping(address => uint256)) public roleRequestTimestamps;\n    mapping(bytes32 => mapping(address => string)) public roleRequestReasons;\n    \n    // Role approval requirements\n    mapping(bytes32 => uint256) public roleApprovalThresholds;\n    mapping(bytes32 => uint256) public roleRequestTimeouts;\n    \n    // ============ Events ============\n    event RoleRequested(\n        bytes32 indexed role,\n        address indexed account,\n        string reason,\n        uint256 timestamp\n    );\n    event RoleRequestExpired(\n        bytes32 indexed role,\n        address indexed account\n    );\n    \n    // ============ Errors ============\n    error ZeroAddress();\n    error RoleAlreadyRequested();\n    error RoleRequestNotFound();\n    error RoleRequestExpiredError();\n    error InsufficientGovernancePower();\n    error InvalidRole();\n    error UnauthorizedRoleManagement();\n    error RoleAlreadyGranted();\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    \n    /**\n     * @notice Initialize the DAO Role Manager\n     * @param _governanceToken The governance token contract\n     * @param _governor The governor contract\n     * @param _timelock The timelock controller\n     */\n    function initialize(\n        IVotes _governanceToken,\n        GovernorUpgradeable _governor,\n        TimelockControllerUpgradeable _timelock\n    ) public initializer {\n        __AccessControl_init();\n        \n        if (address(_governanceToken) == address(0)) revert ZeroAddress();\n        if (address(_governor) == address(0)) revert ZeroAddress();\n        if (address(_timelock) == address(0)) revert ZeroAddress();\n        \n        governanceToken = _governanceToken;\n        governor = _governor;\n        timelock = _timelock;\n        \n        // Set default approval thresholds (percentage of total supply)\n        roleApprovalThresholds[GOVERNANCE_ROLE] = 2000; // 20%\n        roleApprovalThresholds[SECURITY_COUNCIL_ROLE] = 1500; // 15%\n        roleApprovalThresholds[EXECUTOR_ROLE] = 1000; // 10%\n        roleApprovalThresholds[PROPOSER_ROLE] = 500; // 5%\n        roleApprovalThresholds[MINTER_ROLE] = 3000; // 30%\n        \n        // Set default request timeouts (7 days)\n        roleRequestTimeouts[GOVERNANCE_ROLE] = 7 days;\n        roleRequestTimeouts[SECURITY_COUNCIL_ROLE] = 7 days;\n        roleRequestTimeouts[EXECUTOR_ROLE] = 7 days;\n        roleRequestTimeouts[PROPOSER_ROLE] = 7 days;\n        roleRequestTimeouts[MINTER_ROLE] = 7 days;\n        \n        // Grant admin role to timelock\n        _grantRole(DEFAULT_ADMIN_ROLE, address(_timelock));\n    }\n    \n    /**\n     * @notice Request a role (requires governance approval)\n     * @param role The role to request\n     * @param reason Reason for requesting the role\n     */\n    function requestRole(bytes32 role, string memory reason) external {\n        if (role == DEFAULT_ADMIN_ROLE) revert InvalidRole();\n        if (hasRole(role, msg.sender)) revert RoleAlreadyGranted();\n        if (roleRequests[role][msg.sender]) revert RoleAlreadyRequested();\n        \n        // Check if user has sufficient governance power\n        uint256 threshold = roleApprovalThresholds[role];\n        uint256 userPower = governanceToken.getVotes(msg.sender);\n        uint256 totalSupply = governanceToken.getPastTotalSupply(block.number - 1);\n        \n        if (userPower < (totalSupply * threshold) / 10000) {\n            revert InsufficientGovernancePower();\n        }\n        \n        roleRequests[role][msg.sender] = true;\n        roleRequestTimestamps[role][msg.sender] = block.timestamp;\n        roleRequestReasons[role][msg.sender] = reason;\n        \n        emit RoleRequested(role, msg.sender, reason, block.timestamp);\n    }\n    \n    /**\n     * @notice Approve a role request (only governance can call)\n     * @param role The role to approve\n     * @param account The account to grant the role to\n     */\n    function approveRole(bytes32 role, address account) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (!roleRequests[role][account]) revert RoleRequestNotFound();\n        \n        // Check if request has expired\n        uint256 timeout = roleRequestTimeouts[role];\n        if (block.timestamp > roleRequestTimestamps[role][account] + timeout) {\n            revert RoleRequestExpiredError();\n        }\n        \n        // Clear request\n        delete roleRequests[role][account];\n        delete roleRequestTimestamps[role][account];\n        delete roleRequestReasons[role][account];\n        \n        // Grant role\n        _grantRole(role, account);\n        \n        emit RoleGranted(role, account, msg.sender);\n    }\n    \n    /**\n     * @notice Revoke a role (only governance can call)\n     * @param role The role to revoke\n     * @param account The account to revoke the role from\n     */\n    function revokeRole(bytes32 role, address account) public override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _revokeRole(role, account);\n    }\n    \n    /**\n     * @notice Clean up expired role requests\n     * @param role The role to clean up\n     * @param account The account to clean up\n     */\n    function cleanupExpiredRequest(bytes32 role, address account) external {\n        if (!roleRequests[role][account]) revert RoleRequestNotFound();\n        \n        uint256 timeout = roleRequestTimeouts[role];\n        if (block.timestamp <= roleRequestTimestamps[role][account] + timeout) {\n            revert RoleRequestExpiredError();\n        }\n        \n        delete roleRequests[role][account];\n        delete roleRequestTimestamps[role][account];\n        delete roleRequestReasons[role][account];\n        \n        emit RoleRequestExpired(role, account);\n    }\n    \n    /**\n     * @notice Update role approval threshold\n     * @param role The role to update\n     * @param threshold New threshold (basis points)\n     */\n    function updateRoleThreshold(bytes32 role, uint256 threshold) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (threshold > 10000) revert InvalidRole(); // Max 100%\n        roleApprovalThresholds[role] = threshold;\n    }\n    \n    /**\n     * @notice Update role request timeout\n     * @param role The role to update\n     * @param timeout New timeout in seconds\n     */\n    function updateRoleTimeout(bytes32 role, uint256 timeout) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (timeout == 0) revert InvalidRole();\n        roleRequestTimeouts[role] = timeout;\n    }\n    \n    // ============ View Functions ============\n    \n    /**\n     * @notice Check if an account has requested a role\n     */\n    function hasRequestedRole(bytes32 role, address account) external view returns (bool) {\n        return roleRequests[role][account];\n    }\n    \n    /**\n     * @notice Get role request details\n     */\n    function getRoleRequest(bytes32 role, address account) external view returns (\n        bool exists,\n        uint256 timestamp,\n        string memory reason,\n        bool expired\n    ) {\n        exists = roleRequests[role][account];\n        timestamp = roleRequestTimestamps[role][account];\n        reason = roleRequestReasons[role][account];\n        \n        if (exists) {\n            uint256 timeout = roleRequestTimeouts[role];\n            expired = block.timestamp > timestamp + timeout;\n        }\n    }\n    \n    /**\n     * @notice Get role approval threshold\n     */\n    function getRoleThreshold(bytes32 role) external view returns (uint256) {\n        return roleApprovalThresholds[role];\n    }\n    \n    /**\n     * @notice Check if account meets governance requirements for role\n     */\n    function meetsGovernanceRequirements(bytes32 role, address account) external view returns (bool) {\n        uint256 threshold = roleApprovalThresholds[role];\n        uint256 userPower = governanceToken.getVotes(account);\n        uint256 totalSupply = governanceToken.getPastTotalSupply(block.number - 1);\n        \n        return userPower >= (totalSupply * threshold) / 10000;\n    }\n}\n"
    },
    "contracts/security/MultiSigRoleManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\n/**\n * @title MultiSigRoleManager\n * @notice Centralized role management with multi-signature requirements\n * @dev This contract manages all privileged roles across the Hyra protocol\n *      Each role requires multiple signatures for critical operations\n */\ncontract MultiSigRoleManager is Initializable, AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    \n    // ============ Role Definitions ============\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n    bytes32 public constant SECURITY_COUNCIL_ROLE = keccak256(\"SECURITY_COUNCIL_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n    \n    // ============ Multi-signature Configuration ============\n    struct MultiSigConfig {\n        uint256 requiredSignatures;\n        uint256 totalSigners;\n        mapping(address => bool) signers;\n        address[] signerList;\n    }\n    \n    mapping(bytes32 => MultiSigConfig) public roleMultiSigConfigs;\n    \n    // ============ Action Tracking ============\n    struct PendingAction {\n        bytes32 actionHash;\n        address proposer;\n        uint256 timestamp;\n        uint256 requiredSignatures;\n        uint256 currentSignatures;\n        mapping(address => bool) signatures;\n        bool executed;\n    }\n    \n    mapping(bytes32 => PendingAction) public pendingActions;\n    bytes32[] public pendingActionList;\n    \n    // ============ Constants ============\n    uint256 public constant MIN_SIGNATURES = 2;\n    uint256 public constant MAX_SIGNATURES = 7;\n    uint256 public constant ACTION_TIMEOUT = 7 days;\n    \n    // ============ Events ============\n    event RoleMultiSigConfigured(bytes32 indexed role, uint256 requiredSignatures, address[] signers);\n    event ActionProposed(bytes32 indexed actionHash, address indexed proposer, bytes32 indexed role);\n    event ActionSigned(bytes32 indexed actionHash, address indexed signer);\n    event ActionExecuted(bytes32 indexed actionHash);\n    event SignerAdded(bytes32 indexed role, address indexed signer);\n    event SignerRemoved(bytes32 indexed role, address indexed signer);\n    \n    // ============ Errors ============\n    error InvalidSignatures(uint256 required, uint256 provided);\n    error InvalidRole(bytes32 role);\n    error ActionNotFound(bytes32 actionHash);\n    error ActionAlreadyExecuted(bytes32 actionHash);\n    error ActionExpired(bytes32 actionHash);\n    error AlreadySigned(bytes32 actionHash, address signer);\n    error NotAuthorized(bytes32 actionHash);\n    error InvalidSigner(address signer);\n    error DuplicateSigner(address signer);\n    error InsufficientSigners(uint256 current, uint256 minimum);\n    error ExcessiveSigners(uint256 current, uint256 maximum);\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    \n    /**\n     * @notice Initialize the MultiSigRoleManager\n     * @param admin Initial admin address\n     */\n    function initialize(address admin) public initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        \n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        \n        // Set default multi-sig configurations\n        _setDefaultMultiSigConfigs();\n    }\n    \n    /**\n     * @notice Configure multi-signature requirements for a role\n     * @param role The role to configure\n     * @param requiredSignatures Number of signatures required\n     * @param signers Array of signer addresses\n     */\n    function configureRoleMultiSig(\n        bytes32 role,\n        uint256 requiredSignatures,\n        address[] calldata signers\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (requiredSignatures < MIN_SIGNATURES || requiredSignatures > MAX_SIGNATURES) {\n            revert InvalidSignatures(requiredSignatures, requiredSignatures);\n        }\n        \n        if (signers.length < requiredSignatures) {\n            revert InsufficientSigners(signers.length, requiredSignatures);\n        }\n        \n        if (signers.length > MAX_SIGNATURES) {\n            revert ExcessiveSigners(signers.length, MAX_SIGNATURES);\n        }\n        \n        MultiSigConfig storage config = roleMultiSigConfigs[role];\n        config.requiredSignatures = requiredSignatures;\n        config.totalSigners = signers.length;\n        \n        // Clear existing signers\n        for (uint256 i = 0; i < config.signerList.length; i++) {\n            config.signers[config.signerList[i]] = false;\n        }\n        delete config.signerList;\n        \n        // Add new signers\n        for (uint256 i = 0; i < signers.length; i++) {\n            if (signers[i] == address(0)) revert InvalidSigner(signers[i]);\n            if (config.signers[signers[i]]) revert DuplicateSigner(signers[i]);\n            \n            config.signers[signers[i]] = true;\n            config.signerList.push(signers[i]);\n            \n            // Grant the role to the signer\n            _grantRole(role, signers[i]);\n            \n            emit SignerAdded(role, signers[i]);\n        }\n        \n        emit RoleMultiSigConfigured(role, requiredSignatures, signers);\n    }\n    \n    /**\n     * @notice Propose an action that requires multi-signature approval\n     * @param role The role required for this action\n     * @param actionData Encoded action data\n     * @return actionHash Unique identifier for this action\n     */\n    function proposeAction(\n        bytes32 role,\n        bytes calldata actionData\n    ) external onlyRole(role) nonReentrant returns (bytes32) {\n        bytes32 actionHash = keccak256(abi.encodePacked(role, actionData, block.timestamp, msg.sender));\n        \n        if (pendingActions[actionHash].timestamp != 0) {\n            revert ActionNotFound(actionHash);\n        }\n        \n        MultiSigConfig storage config = roleMultiSigConfigs[role];\n        \n        PendingAction storage action = pendingActions[actionHash];\n        action.actionHash = actionHash;\n        action.proposer = msg.sender;\n        action.timestamp = block.timestamp;\n        action.requiredSignatures = config.requiredSignatures;\n        action.currentSignatures = 1; // Proposer automatically signs\n        action.signatures[msg.sender] = true;\n        action.executed = false;\n        \n        pendingActionList.push(actionHash);\n        \n        emit ActionProposed(actionHash, msg.sender, role);\n        emit ActionSigned(actionHash, msg.sender);\n        \n        return actionHash;\n    }\n    \n    /**\n     * @notice Sign a pending action\n     * @param actionHash The action to sign\n     */\n    function signAction(bytes32 actionHash) external nonReentrant {\n        PendingAction storage action = pendingActions[actionHash];\n        \n        if (action.timestamp == 0) revert ActionNotFound(actionHash);\n        if (action.executed) revert ActionAlreadyExecuted(actionHash);\n        if (block.timestamp > action.timestamp + ACTION_TIMEOUT) revert ActionExpired(actionHash);\n        if (action.signatures[msg.sender]) revert AlreadySigned(actionHash, msg.sender);\n        \n        // Check if signer has the required role\n        bytes32 role = _getRoleFromActionHash(actionHash);\n        if (!hasRole(role, msg.sender)) revert NotAuthorized(actionHash);\n        \n        action.signatures[msg.sender] = true;\n        action.currentSignatures++;\n        \n        emit ActionSigned(actionHash, msg.sender);\n        \n        // Auto-execute if enough signatures\n        if (action.currentSignatures >= action.requiredSignatures) {\n            _executeAction(actionHash);\n        }\n    }\n    \n    /**\n     * @notice Execute a fully signed action\n     * @param actionHash The action to execute\n     */\n    function executeAction(bytes32 actionHash) external nonReentrant {\n        PendingAction storage action = pendingActions[actionHash];\n        \n        if (action.timestamp == 0) revert ActionNotFound(actionHash);\n        if (action.executed) revert ActionAlreadyExecuted(actionHash);\n        if (block.timestamp > action.timestamp + ACTION_TIMEOUT) revert ActionExpired(actionHash);\n        if (action.currentSignatures < action.requiredSignatures) revert InvalidSignatures(action.requiredSignatures, action.currentSignatures);\n        \n        _executeAction(actionHash);\n    }\n    \n    /**\n     * @notice Check if an action can be executed\n     * @param actionHash The action to check\n     * @return canExecute True if action can be executed\n     */\n    function canExecuteAction(bytes32 actionHash) external view returns (bool) {\n        PendingAction storage action = pendingActions[actionHash];\n        \n        return action.timestamp != 0 && \n               !action.executed && \n               block.timestamp <= action.timestamp + ACTION_TIMEOUT &&\n               action.currentSignatures >= action.requiredSignatures;\n    }\n    \n    /**\n     * @notice Get action details\n     * @param actionHash The action hash\n     * @return proposer The proposer address\n     * @return timestamp When the action was proposed\n     * @return requiredSignatures Required number of signatures\n     * @return currentSignatures Current number of signatures\n     * @return executed Whether the action has been executed\n     */\n    function getActionDetails(bytes32 actionHash) external view returns (\n        address proposer,\n        uint256 timestamp,\n        uint256 requiredSignatures,\n        uint256 currentSignatures,\n        bool executed\n    ) {\n        PendingAction storage action = pendingActions[actionHash];\n        \n        return (\n            action.proposer,\n            action.timestamp,\n            action.requiredSignatures,\n            action.currentSignatures,\n            action.executed\n        );\n    }\n    \n    /**\n     * @notice Get all pending actions\n     * @return actions Array of pending action hashes\n     */\n    function getPendingActions() external view returns (bytes32[] memory) {\n        return pendingActionList;\n    }\n    \n    /**\n     * @notice Get signers for a role\n     * @param role The role\n     * @return signers Array of signer addresses\n     */\n    function getRoleSigners(bytes32 role) external view returns (address[] memory) {\n        return roleMultiSigConfigs[role].signerList;\n    }\n    \n    /**\n     * @notice Check if an address is a signer for a role\n     * @param role The role\n     * @param signer The address to check\n     * @return isSigner True if the address is a signer\n     */\n    function isRoleSigner(bytes32 role, address signer) external view returns (bool) {\n        return roleMultiSigConfigs[role].signers[signer];\n    }\n    \n    // ============ Internal Functions ============\n    \n    /**\n     * @notice Execute a fully signed action\n     * @param actionHash The action to execute\n     */\n    function _executeAction(bytes32 actionHash) internal {\n        PendingAction storage action = pendingActions[actionHash];\n        action.executed = true;\n        \n        emit ActionExecuted(actionHash);\n        \n        // FIXED: Remove from pending list - avoid strict equality\n        uint256 pendingLength = pendingActionList.length;\n        for (uint256 i = 0; i < pendingLength; i++) {\n            // Use keccak256 comparison instead of strict equality\n            if (keccak256(abi.encodePacked(pendingActionList[i])) == keccak256(abi.encodePacked(actionHash))) {\n                pendingActionList[i] = pendingActionList[pendingLength - 1];\n                pendingActionList.pop();\n                break;\n            }\n        }\n    }\n    \n    /**\n     * @notice Get role from action hash (simplified implementation)\n     * @param actionHash The action hash\n     * @return role The role\n     */\n    function _getRoleFromActionHash(bytes32 actionHash) internal pure returns (bytes32) {\n        // This is a simplified implementation\n        // In a real implementation, you would decode the action data\n        return GOVERNANCE_ROLE;\n    }\n    \n    /**\n     * @notice Set default multi-signature configurations\n     */\n    function _setDefaultMultiSigConfigs() internal {\n        // Default configurations will be set by admin after deployment\n        // This function is a placeholder for future default settings\n    }\n}\n"
    },
    "contracts/security/ProxyAdminValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\n/**\n * @title ProxyAdminValidator\n * @notice Validates legitimate proxy admin addresses to prevent fake proxy admin attacks\n * @dev Implements secure proxy admin validation to prevent unauthorized upgrades\n */\ncontract ProxyAdminValidator is Initializable, AccessControlUpgradeable {\n    // ============ Constants ============\n    bytes32 public constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n    \n    // ============ State Variables ============\n    mapping(address => bool) public authorizedProxyAdmins;\n    mapping(address => ProxyAdminInfo) public proxyAdminInfo;\n    \n    struct ProxyAdminInfo {\n        string name;\n        address owner;\n        bool isActive;\n        uint256 addedTimestamp;\n        string description;\n    }\n    \n    // ============ Events ============\n    event ProxyAdminAuthorized(\n        address indexed proxyAdmin,\n        string name,\n        address indexed owner,\n        string description\n    );\n    event ProxyAdminDeauthorized(address indexed proxyAdmin, address indexed deauthorizedBy);\n    event ProxyAdminUpdated(\n        address indexed proxyAdmin,\n        string newName,\n        address newOwner,\n        string newDescription\n    );\n    event ProxyAdminValidated(address indexed proxyAdmin, address indexed validator, bool isValid);\n    \n    // ============ Errors ============\n    error ZeroAddress();\n    error ProxyAdminAlreadyAuthorized();\n    error ProxyAdminNotAuthorized();\n    error ProxyAdminNotActive();\n    error InvalidProxyAdmin();\n    error UnauthorizedValidator();\n    error InvalidParameters();\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    \n    /**\n     * @notice Initialize the Proxy Admin Validator\n     * @param admin Initial admin address\n     */\n    function initialize(address admin) public initializer {\n        __AccessControl_init();\n        \n        if (admin == address(0)) revert ZeroAddress();\n        \n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(VALIDATOR_ROLE, admin);\n    }\n    \n    /**\n     * @notice Authorize a proxy admin address\n     * @param proxyAdmin Address of the proxy admin to authorize\n     * @param name Human-readable name for the proxy admin\n     * @param owner Owner of the proxy admin\n     * @param description Description of the proxy admin's purpose\n     */\n    function authorizeProxyAdmin(\n        address proxyAdmin,\n        string memory name,\n        address owner,\n        string memory description\n    ) external onlyRole(VALIDATOR_ROLE) {\n        if (proxyAdmin == address(0)) revert ZeroAddress();\n        if (owner == address(0)) revert ZeroAddress();\n        if (authorizedProxyAdmins[proxyAdmin]) revert ProxyAdminAlreadyAuthorized();\n        \n        // Validate that the address is a contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(proxyAdmin)\n        }\n        if (codeSize == 0) revert InvalidProxyAdmin();\n        \n        authorizedProxyAdmins[proxyAdmin] = true;\n        proxyAdminInfo[proxyAdmin] = ProxyAdminInfo({\n            name: name,\n            owner: owner,\n            isActive: true,\n            addedTimestamp: block.timestamp,\n            description: description\n        });\n        \n        emit ProxyAdminAuthorized(proxyAdmin, name, owner, description);\n    }\n    \n    /**\n     * @notice Deauthorize a proxy admin address\n     * @param proxyAdmin Address of the proxy admin to deauthorize\n     */\n    function deauthorizeProxyAdmin(address proxyAdmin) external onlyRole(VALIDATOR_ROLE) {\n        if (!authorizedProxyAdmins[proxyAdmin]) revert ProxyAdminNotAuthorized();\n        \n        authorizedProxyAdmins[proxyAdmin] = false;\n        proxyAdminInfo[proxyAdmin].isActive = false;\n        \n        emit ProxyAdminDeauthorized(proxyAdmin, msg.sender);\n    }\n    \n    /**\n     * @notice Update proxy admin information\n     * @param proxyAdmin Address of the proxy admin to update\n     * @param name New name\n     * @param owner New owner\n     * @param description New description\n     */\n    function updateProxyAdmin(\n        address proxyAdmin,\n        string memory name,\n        address owner,\n        string memory description\n    ) external onlyRole(VALIDATOR_ROLE) {\n        if (!authorizedProxyAdmins[proxyAdmin]) revert ProxyAdminNotAuthorized();\n        if (owner == address(0)) revert ZeroAddress();\n        \n        proxyAdminInfo[proxyAdmin].name = name;\n        proxyAdminInfo[proxyAdmin].owner = owner;\n        proxyAdminInfo[proxyAdmin].description = description;\n        \n        emit ProxyAdminUpdated(proxyAdmin, name, owner, description);\n    }\n    \n    /**\n     * @notice Validate a proxy admin address\n     * @param proxyAdmin Address to validate\n     * @return isValid Whether the proxy admin is valid and authorized\n     * @return info Proxy admin information\n     */\n    function validateProxyAdmin(address proxyAdmin) external view returns (bool isValid, ProxyAdminInfo memory info) {\n        info = proxyAdminInfo[proxyAdmin];\n        isValid = authorizedProxyAdmins[proxyAdmin] && info.isActive;\n        \n        // Emit validation event for tracking\n        // Note: This is a view function, so events won't actually be emitted\n        // In production, consider using a separate tracking contract\n    }\n    \n    /**\n     * @notice Batch validate multiple proxy admin addresses\n     * @param proxyAdmins Array of proxy admin addresses to validate\n     * @return results Array of validation results\n     */\n    function batchValidateProxyAdmins(address[] memory proxyAdmins) \n        external \n        view \n        returns (bool[] memory results) \n    {\n        results = new bool[](proxyAdmins.length);\n        \n        for (uint256 i = 0; i < proxyAdmins.length; i++) {\n            results[i] = authorizedProxyAdmins[proxyAdmins[i]] && proxyAdminInfo[proxyAdmins[i]].isActive;\n        }\n    }\n    \n    /**\n     * @notice Check if proxy admin is authorized and active\n     * @param proxyAdmin Address to check\n     * @return Whether the proxy admin is authorized and active\n     */\n    function isAuthorizedProxyAdmin(address proxyAdmin) external view returns (bool) {\n        return authorizedProxyAdmins[proxyAdmin] && proxyAdminInfo[proxyAdmin].isActive;\n    }\n    \n    /**\n     * @notice Get proxy admin information\n     * @param proxyAdmin Address of the proxy admin\n     * @return info Proxy admin information\n     */\n    function getProxyAdminInfo(address proxyAdmin) external view returns (ProxyAdminInfo memory info) {\n        if (!authorizedProxyAdmins[proxyAdmin]) revert ProxyAdminNotAuthorized();\n        return proxyAdminInfo[proxyAdmin];\n    }\n    \n    /**\n     * @notice Emergency deauthorization (only admin)\n     * @param proxyAdmin Address to emergency deauthorize\n     */\n    function emergencyDeauthorize(address proxyAdmin) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (authorizedProxyAdmins[proxyAdmin]) {\n            authorizedProxyAdmins[proxyAdmin] = false;\n            proxyAdminInfo[proxyAdmin].isActive = false;\n            emit ProxyAdminDeauthorized(proxyAdmin, msg.sender);\n        }\n    }\n    \n    /**\n     * @notice Add validator role\n     * @param validator Address to grant validator role\n     */\n    function addValidator(address validator) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (validator == address(0)) revert ZeroAddress();\n        _grantRole(VALIDATOR_ROLE, validator);\n    }\n    \n    /**\n     * @notice Remove validator role\n     * @param validator Address to revoke validator role\n     */\n    function removeValidator(address validator) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _revokeRole(VALIDATOR_ROLE, validator);\n    }\n    \n    /**\n     * @notice Get all authorized proxy admins (gas-intensive, use with caution)\n     * @dev This function is not recommended for large numbers of proxy admins\n     * @return proxyAdmins Array of authorized proxy admin addresses\n     */\n    function getAllAuthorizedProxyAdmins() external view returns (address[] memory proxyAdmins) {\n        // This is a simplified implementation\n        // In production, you might want to maintain a separate array for efficiency\n        // For now, this returns an empty array as a placeholder\n        proxyAdmins = new address[](0);\n    }\n}\n"
    },
    "contracts/security/SecureExecutorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\n/**\n * @title SecureExecutorManager\n * @notice Secure executor management system that replaces address(0) executors\n * @dev Implements secure execution patterns with proper access controls\n */\ncontract SecureExecutorManager is Initializable, AccessControlUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    // ============ Constants ============\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n    \n    // ============ State Variables ============\n    mapping(address => bool) public authorizedExecutors;\n    mapping(address => uint256) public executorLastUsed;\n    mapping(address => uint256) public executorUsageCount;\n    \n    uint256 public maxExecutorsPerDay = 1000;\n    uint256 public executorCooldownPeriod = 1 hours;\n    uint256 public emergencyExecutorThreshold = 3; // Minimum executors for emergency mode\n    \n    // Execution tracking\n    mapping(bytes32 => bool) public executedOperations;\n    mapping(bytes32 => address) public operationExecutors;\n    mapping(bytes32 => uint256) public operationTimestamps;\n    \n    // ============ Events ============\n    event ExecutorAdded(address indexed executor, address indexed addedBy);\n    event ExecutorRemoved(address indexed executor, address indexed removedBy);\n    event OperationExecuted(\n        bytes32 indexed operationId,\n        address indexed executor,\n        address indexed target,\n        uint256 timestamp\n    );\n    event EmergencyModeActivated(address indexed activatedBy);\n    event EmergencyModeDeactivated(address indexed deactivatedBy);\n    event ExecutorLimitUpdated(uint256 oldLimit, uint256 newLimit);\n    event CooldownPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\n    \n    // ============ Errors ============\n    error ZeroAddress();\n    error AlreadyExecutor();\n    error NotExecutor();\n    error ExecutorCooldownActive();\n    error ExecutorLimitExceeded();\n    error OperationAlreadyExecuted();\n    error InvalidOperation();\n    error InsufficientExecutors();\n    error EmergencyModeRequired();\n    error UnauthorizedExecutor();\n    error InvalidParameters();\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    \n    /**\n     * @notice Initialize the Secure Executor Manager\n     * @param admin Initial admin address\n     * @param initialExecutors Array of initial executor addresses\n     */\n    function initialize(\n        address admin,\n        address[] memory initialExecutors\n    ) public initializer {\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        \n        if (admin == address(0)) revert ZeroAddress();\n        \n        // Grant roles\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(MANAGER_ROLE, admin);\n        _grantRole(EMERGENCY_ROLE, admin);\n        \n        // Add initial executors\n        for (uint256 i = 0; i < initialExecutors.length; i++) {\n            if (initialExecutors[i] != address(0)) {\n                _addExecutor(initialExecutors[i]);\n            }\n        }\n        \n        // Ensure we have at least one executor\n        require(initialExecutors.length > 0, \"At least one executor required\");\n    }\n    \n    /**\n     * @notice Add a new executor\n     * @param executor Address of the executor to add\n     */\n    function addExecutor(address executor) external onlyRole(MANAGER_ROLE) {\n        if (executor == address(0)) revert ZeroAddress();\n        _addExecutor(executor);\n        emit ExecutorAdded(executor, msg.sender);\n    }\n    \n    /**\n     * @notice Remove an executor\n     * @param executor Address of the executor to remove\n     */\n    function removeExecutor(address executor) external onlyRole(MANAGER_ROLE) {\n        if (!authorizedExecutors[executor]) revert NotExecutor();\n        \n        // Check if removing this executor would leave insufficient executors\n        uint256 executorCount = _getExecutorCount();\n        if (executorCount <= 1) {\n            revert InsufficientExecutors();\n        }\n        \n        authorizedExecutors[executor] = false;\n        delete executorLastUsed[executor];\n        delete executorUsageCount[executor];\n        \n        emit ExecutorRemoved(executor, msg.sender);\n    }\n    \n    /**\n     * @notice Execute an operation (replaces address(0) execution)\n     * @param operationId Unique identifier for the operation\n     * @param target Target contract address\n     * @param data Call data\n     * @param value ETH value to send\n     */\n    function executeOperation(\n        bytes32 operationId,\n        address target,\n        bytes memory data,\n        uint256 value\n    ) external nonReentrant whenNotPaused returns (bool success, bytes memory returnData) {\n        // Check if caller is authorized executor\n        if (!authorizedExecutors[msg.sender]) revert UnauthorizedExecutor();\n        \n        // Check if operation already executed\n        if (executedOperations[operationId]) revert OperationAlreadyExecuted();\n        \n        // Check executor cooldown\n        if (block.timestamp < executorLastUsed[msg.sender] + executorCooldownPeriod) {\n            revert ExecutorCooldownActive();\n        }\n        \n        // Check daily usage limit\n        if (executorUsageCount[msg.sender] >= maxExecutorsPerDay) {\n            revert ExecutorLimitExceeded();\n        }\n        \n        // Validate target\n        if (target == address(0)) revert InvalidOperation();\n        \n        // Mark operation as executed\n        executedOperations[operationId] = true;\n        operationExecutors[operationId] = msg.sender;\n        operationTimestamps[operationId] = block.timestamp;\n        \n        // Update executor usage\n        executorLastUsed[msg.sender] = block.timestamp;\n        executorUsageCount[msg.sender]++;\n        \n        // Execute the operation\n        (success, returnData) = target.call{value: value}(data);\n        \n        emit OperationExecuted(operationId, msg.sender, target, block.timestamp);\n        \n        return (success, returnData);\n    }\n    \n    /**\n     * @notice Emergency execution (bypasses some restrictions)\n     * @param operationId Unique identifier for the operation\n     * @param target Target contract address\n     * @param data Call data\n     * @param value ETH value to send\n     */\n    function emergencyExecute(\n        bytes32 operationId,\n        address target,\n        bytes memory data,\n        uint256 value\n    ) external onlyRole(EMERGENCY_ROLE) nonReentrant returns (bool success, bytes memory returnData) {\n        // Check if operation already executed\n        if (executedOperations[operationId]) revert OperationAlreadyExecuted();\n        \n        // Validate target\n        if (target == address(0)) revert InvalidOperation();\n        \n        // Mark operation as executed\n        executedOperations[operationId] = true;\n        operationExecutors[operationId] = msg.sender;\n        operationTimestamps[operationId] = block.timestamp;\n        \n        // Execute the operation\n        (success, returnData) = target.call{value: value}(data);\n        \n        emit OperationExecuted(operationId, msg.sender, target, block.timestamp);\n        \n        return (success, returnData);\n    }\n    \n    /**\n     * @notice Activate emergency mode (anyone can execute)\n     */\n    function activateEmergencyMode() external onlyRole(EMERGENCY_ROLE) {\n        _pause();\n        emit EmergencyModeActivated(msg.sender);\n    }\n    \n    /**\n     * @notice Deactivate emergency mode\n     */\n    function deactivateEmergencyMode() external onlyRole(EMERGENCY_ROLE) {\n        _unpause();\n        emit EmergencyModeDeactivated(msg.sender);\n    }\n    \n    /**\n     * @notice Update executor daily limit\n     * @param newLimit New daily limit\n     */\n    function updateExecutorLimit(uint256 newLimit) external onlyRole(MANAGER_ROLE) {\n        uint256 oldLimit = maxExecutorsPerDay;\n        maxExecutorsPerDay = newLimit;\n        emit ExecutorLimitUpdated(oldLimit, newLimit);\n    }\n    \n    /**\n     * @notice Update executor cooldown period\n     * @param newPeriod New cooldown period in seconds\n     */\n    function updateCooldownPeriod(uint256 newPeriod) external onlyRole(MANAGER_ROLE) {\n        uint256 oldPeriod = executorCooldownPeriod;\n        executorCooldownPeriod = newPeriod;\n        emit CooldownPeriodUpdated(oldPeriod, newPeriod);\n    }\n    \n    // ============ Internal Functions ============\n    \n    function _addExecutor(address executor) internal {\n        if (authorizedExecutors[executor]) revert AlreadyExecutor();\n        authorizedExecutors[executor] = true;\n        _grantRole(EXECUTOR_ROLE, executor);\n    }\n    \n    function _getExecutorCount() internal view returns (uint256 count) {\n        // This is a simplified count - in production, you might want to track this separately\n        // For now, we'll use a reasonable assumption that authorized executors are manageable\n        return 10; // Placeholder - implement proper counting if needed\n    }\n    \n    // ============ View Functions ============\n    \n    /**\n     * @notice Check if an address is an authorized executor\n     */\n    function isAuthorizedExecutor(address executor) external view returns (bool) {\n        return authorizedExecutors[executor];\n    }\n    \n    /**\n     * @notice Check if executor can execute (not in cooldown, within limits)\n     */\n    function canExecute(address executor) external view returns (bool) {\n        if (!authorizedExecutors[executor]) return false;\n        if (block.timestamp < executorLastUsed[executor] + executorCooldownPeriod) return false;\n        if (executorUsageCount[executor] >= maxExecutorsPerDay) return false;\n        return true;\n    }\n    \n    /**\n     * @notice Get executor usage information\n     */\n    function getExecutorInfo(address executor) external view returns (\n        bool authorized,\n        uint256 lastUsed,\n        uint256 usageCount,\n        bool canExecuteNow\n    ) {\n        authorized = authorizedExecutors[executor];\n        lastUsed = executorLastUsed[executor];\n        usageCount = executorUsageCount[executor];\n        canExecuteNow = authorized && \n                       block.timestamp >= lastUsed + executorCooldownPeriod &&\n                       usageCount < maxExecutorsPerDay;\n    }\n    \n    /**\n     * @notice Check if operation was executed\n     */\n    function wasOperationExecuted(bytes32 operationId) external view returns (bool) {\n        return executedOperations[operationId];\n    }\n    \n    /**\n     * @notice Get operation details\n     */\n    function getOperationDetails(bytes32 operationId) external view returns (\n        bool executed,\n        address executor,\n        uint256 timestamp\n    ) {\n        executed = executedOperations[operationId];\n        executor = operationExecutors[operationId];\n        timestamp = operationTimestamps[operationId];\n    }\n}\n"
    },
    "contracts/security/SimpleMultiSigRoleManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title SimpleMultiSigRoleManager\n * @notice Simplified multi-signature role management for testing\n * @dev This contract manages roles with multi-signature requirements\n */\ncontract SimpleMultiSigRoleManager is AccessControl, ReentrancyGuard {\n    \n    // ============ Role Definitions ============\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n    bytes32 public constant SECURITY_COUNCIL_ROLE = keccak256(\"SECURITY_COUNCIL_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n    \n    // ============ Multi-signature Configuration ============\n    struct MultiSigConfig {\n        uint256 requiredSignatures;\n        uint256 totalSigners;\n        mapping(address => bool) signers;\n        address[] signerList;\n    }\n    \n    mapping(bytes32 => MultiSigConfig) public roleMultiSigConfigs;\n    \n    // ============ Action Tracking ============\n    struct PendingAction {\n        bytes32 actionHash;\n        address proposer;\n        uint256 timestamp;\n        uint256 requiredSignatures;\n        uint256 currentSignatures;\n        mapping(address => bool) signatures;\n        bool executed;\n    }\n    \n    mapping(bytes32 => PendingAction) public pendingActions;\n    bytes32[] public pendingActionList;\n    \n    // ============ Constants ============\n    uint256 public constant MIN_SIGNATURES = 2;\n    uint256 public constant MAX_SIGNATURES = 7;\n    uint256 public constant ACTION_TIMEOUT = 7 days;\n    \n    // ============ Events ============\n    event RoleMultiSigConfigured(bytes32 indexed role, uint256 requiredSignatures, address[] signers);\n    event ActionProposed(bytes32 indexed actionHash, address indexed proposer, bytes32 indexed role);\n    event ActionSigned(bytes32 indexed actionHash, address indexed signer);\n    event ActionExecuted(bytes32 indexed actionHash);\n    event SignerAdded(bytes32 indexed role, address indexed signer);\n    event SignerRemoved(bytes32 indexed role, address indexed signer);\n    \n    // ============ Errors ============\n    error InvalidSignatures(uint256 required, uint256 provided);\n    error InvalidRole(bytes32 role);\n    error ActionNotFound(bytes32 actionHash);\n    error ActionAlreadyExecuted(bytes32 actionHash);\n    error ActionExpired(bytes32 actionHash);\n    error AlreadySigned(bytes32 actionHash, address signer);\n    error NotAuthorized(bytes32 actionHash);\n    error InvalidSigner(address signer);\n    error DuplicateSigner(address signer);\n    error InsufficientSigners(uint256 current, uint256 minimum);\n    error ExcessiveSigners(uint256 current, uint256 maximum);\n    \n    /**\n     * @notice Constructor\n     * @param admin Initial admin address\n     */\n    constructor(address admin) {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    }\n    \n    /**\n     * @notice Configure multi-signature requirements for a role\n     * @param role The role to configure\n     * @param requiredSignatures Number of signatures required\n     * @param signers Array of signer addresses\n     */\n    function configureRoleMultiSig(\n        bytes32 role,\n        uint256 requiredSignatures,\n        address[] calldata signers\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (requiredSignatures < MIN_SIGNATURES || requiredSignatures > MAX_SIGNATURES) {\n            revert InvalidSignatures(requiredSignatures, requiredSignatures);\n        }\n        \n        if (signers.length < requiredSignatures) {\n            revert InsufficientSigners(signers.length, requiredSignatures);\n        }\n        \n        if (signers.length > MAX_SIGNATURES) {\n            revert ExcessiveSigners(signers.length, MAX_SIGNATURES);\n        }\n        \n        MultiSigConfig storage config = roleMultiSigConfigs[role];\n        config.requiredSignatures = requiredSignatures;\n        config.totalSigners = signers.length;\n        \n        // Clear existing signers\n        for (uint256 i = 0; i < config.signerList.length; i++) {\n            config.signers[config.signerList[i]] = false;\n        }\n        delete config.signerList;\n        \n        // Add new signers\n        for (uint256 i = 0; i < signers.length; i++) {\n            if (signers[i] == address(0)) revert InvalidSigner(signers[i]);\n            if (config.signers[signers[i]]) revert DuplicateSigner(signers[i]);\n            \n            config.signers[signers[i]] = true;\n            config.signerList.push(signers[i]);\n            \n            // Grant the role to the signer\n            _grantRole(role, signers[i]);\n            \n            emit SignerAdded(role, signers[i]);\n        }\n        \n        emit RoleMultiSigConfigured(role, requiredSignatures, signers);\n    }\n    \n    /**\n     * @notice Propose an action that requires multi-signature approval\n     * @param role The role required for this action\n     * @param actionData Encoded action data\n     * @return actionHash Unique identifier for this action\n     */\n    function proposeAction(\n        bytes32 role,\n        bytes calldata actionData\n    ) external onlyRole(role) nonReentrant returns (bytes32) {\n        bytes32 actionHash = keccak256(abi.encodePacked(role, actionData, block.timestamp, msg.sender));\n        \n        if (pendingActions[actionHash].timestamp != 0) {\n            revert ActionNotFound(actionHash);\n        }\n        \n        MultiSigConfig storage config = roleMultiSigConfigs[role];\n        \n        PendingAction storage action = pendingActions[actionHash];\n        action.actionHash = actionHash;\n        action.proposer = msg.sender;\n        action.timestamp = block.timestamp;\n        action.requiredSignatures = config.requiredSignatures;\n        action.currentSignatures = 1; // Proposer automatically signs\n        action.signatures[msg.sender] = true;\n        action.executed = false;\n        \n        pendingActionList.push(actionHash);\n        \n        emit ActionProposed(actionHash, msg.sender, role);\n        emit ActionSigned(actionHash, msg.sender);\n        \n        return actionHash;\n    }\n    \n    /**\n     * @notice Sign a pending action\n     * @param actionHash The action to sign\n     */\n    function signAction(bytes32 actionHash) external nonReentrant {\n        PendingAction storage action = pendingActions[actionHash];\n        \n        if (action.timestamp == 0) revert ActionNotFound(actionHash);\n        if (action.executed) revert ActionAlreadyExecuted(actionHash);\n        if (block.timestamp > action.timestamp + ACTION_TIMEOUT) revert ActionExpired(actionHash);\n        if (action.signatures[msg.sender]) revert AlreadySigned(actionHash, msg.sender);\n        \n        // Check if signer has the required role\n        bytes32 role = _getRoleFromActionHash(actionHash);\n        if (!hasRole(role, msg.sender)) revert NotAuthorized(actionHash);\n        \n        action.signatures[msg.sender] = true;\n        action.currentSignatures++;\n        \n        emit ActionSigned(actionHash, msg.sender);\n        \n        // Auto-execute if enough signatures\n        if (action.currentSignatures >= action.requiredSignatures) {\n            _executeAction(actionHash);\n        }\n    }\n    \n    /**\n     * @notice Execute a fully signed action\n     * @param actionHash The action to execute\n     */\n    function executeAction(bytes32 actionHash) external nonReentrant {\n        PendingAction storage action = pendingActions[actionHash];\n        \n        if (action.timestamp == 0) revert ActionNotFound(actionHash);\n        if (action.executed) revert ActionAlreadyExecuted(actionHash);\n        if (block.timestamp > action.timestamp + ACTION_TIMEOUT) revert ActionExpired(actionHash);\n        if (action.currentSignatures < action.requiredSignatures) revert InvalidSignatures(action.requiredSignatures, action.currentSignatures);\n        \n        _executeAction(actionHash);\n    }\n    \n    /**\n     * @notice Check if an action can be executed\n     * @param actionHash The action to check\n     * @return canExecute True if action can be executed\n     */\n    function canExecuteAction(bytes32 actionHash) external view returns (bool) {\n        PendingAction storage action = pendingActions[actionHash];\n        \n        return action.timestamp != 0 && \n               !action.executed && \n               block.timestamp <= action.timestamp + ACTION_TIMEOUT &&\n               action.currentSignatures >= action.requiredSignatures;\n    }\n    \n    /**\n     * @notice Get action details\n     * @param actionHash The action hash\n     * @return proposer The proposer address\n     * @return timestamp When the action was proposed\n     * @return requiredSignatures Required number of signatures\n     * @return currentSignatures Current number of signatures\n     * @return executed Whether the action has been executed\n     */\n    function getActionDetails(bytes32 actionHash) external view returns (\n        address proposer,\n        uint256 timestamp,\n        uint256 requiredSignatures,\n        uint256 currentSignatures,\n        bool executed\n    ) {\n        PendingAction storage action = pendingActions[actionHash];\n        \n        return (\n            action.proposer,\n            action.timestamp,\n            action.requiredSignatures,\n            action.currentSignatures,\n            action.executed\n        );\n    }\n    \n    /**\n     * @notice Get all pending actions\n     * @return actions Array of pending action hashes\n     */\n    function getPendingActions() external view returns (bytes32[] memory) {\n        return pendingActionList;\n    }\n    \n    /**\n     * @notice Get signers for a role\n     * @param role The role\n     * @return signers Array of signer addresses\n     */\n    function getRoleSigners(bytes32 role) external view returns (address[] memory) {\n        return roleMultiSigConfigs[role].signerList;\n    }\n    \n    /**\n     * @notice Check if an address is a signer for a role\n     * @param role The role\n     * @param signer The address to check\n     * @return isSigner True if the address is a signer\n     */\n    function isRoleSigner(bytes32 role, address signer) external view returns (bool) {\n        return roleMultiSigConfigs[role].signers[signer];\n    }\n    \n    // ============ Internal Functions ============\n    \n    /**\n     * @notice Execute a fully signed action\n     * @param actionHash The action to execute\n     */\n    function _executeAction(bytes32 actionHash) internal {\n        PendingAction storage action = pendingActions[actionHash];\n        action.executed = true;\n        \n        emit ActionExecuted(actionHash);\n        \n        // Remove from pending list\n        for (uint256 i = 0; i < pendingActionList.length; i++) {\n            if (pendingActionList[i] == actionHash) {\n                pendingActionList[i] = pendingActionList[pendingActionList.length - 1];\n                pendingActionList.pop();\n                break;\n            }\n        }\n    }\n    \n    /**\n     * @notice Get role from action hash (simplified implementation)\n     * @param actionHash The action hash\n     * @return role The role\n     */\n    function _getRoleFromActionHash(bytes32 actionHash) internal pure returns (bytes32) {\n        // This is a simplified implementation\n        // In a real implementation, you would decode the action data\n        return GOVERNANCE_ROLE;\n    }\n}\n"
    },
    "contracts/security/TimeLockActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"./MultiSigRoleManager.sol\";\n\n/**\n * @title TimeLockActions\n * @notice Manages time-delayed actions for privileged operations\n * @dev This contract enforces delays on critical operations to allow community review\n */\ncontract TimeLockActions is Initializable, ReentrancyGuardUpgradeable {\n    \n    // ============ State Variables ============\n    MultiSigRoleManager public roleManager;\n    \n    struct ScheduledAction {\n        bytes32 actionHash;\n        address target;\n        bytes data;\n        uint256 executeTime;\n        bool executed;\n        bool cancelled;\n        address proposer;\n        bytes32 role;\n    }\n    \n    mapping(bytes32 => ScheduledAction) public scheduledActions;\n    bytes32[] public scheduledActionList;\n    \n    // ============ Configuration ============\n    uint256 public constant MIN_DELAY = 2 hours;\n    uint256 public constant MAX_DELAY = 30 days;\n    uint256 public constant DEFAULT_DELAY = 48 hours;\n    \n    // Role-specific delays\n    mapping(bytes32 => uint256) public roleDelays;\n    \n    // ============ Events ============\n    event ActionScheduled(\n        bytes32 indexed actionHash,\n        address indexed target,\n        bytes32 indexed role,\n        uint256 executeTime,\n        address proposer\n    );\n    event ActionExecuted(bytes32 indexed actionHash, address indexed target);\n    event ActionCancelled(bytes32 indexed actionHash, address indexed proposer);\n    event DelayUpdated(bytes32 indexed role, uint256 oldDelay, uint256 newDelay);\n    \n    // ============ Errors ============\n    error InvalidDelay(uint256 delay);\n    error ActionNotFound(bytes32 actionHash);\n    error AlreadyScheduled(bytes32 actionHash);\n    error ActionNotReady(bytes32 actionHash, uint256 executeTime);\n    error ActionAlreadyExecuted(bytes32 actionHash);\n    error ActionAlreadyCancelled(bytes32 actionHash);\n    error Unauthorized(bytes32 actionHash);\n    error InvalidTarget(address target);\n    error InvalidData(bytes data);\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    \n    /**\n     * @notice Initialize the TimeLockActions contract\n     * @param _roleManager Address of the MultiSigRoleManager\n     */\n    function initialize(address _roleManager) public initializer {\n        __ReentrancyGuard_init();\n        \n        roleManager = MultiSigRoleManager(_roleManager);\n        \n        // Set default delays for different roles\n        _setDefaultDelays();\n    }\n    \n    /**\n     * @notice Schedule an action for future execution\n     * @param target Target contract address\n     * @param data Encoded function call data\n     * @param role Required role for this action\n     * @param delay Custom delay (0 for default)\n     * @return actionHash Unique identifier for this action\n     */\n    function scheduleAction(\n        address target,\n        bytes calldata data,\n        bytes32 role,\n        uint256 delay\n    ) external nonReentrant returns (bytes32) {\n        if (target == address(0)) revert InvalidTarget(target);\n        if (data.length == 0) revert InvalidData(data);\n        \n        // Use default delay if not specified\n        if (delay == 0) {\n            delay = roleDelays[role];\n            if (delay == 0) {\n                delay = DEFAULT_DELAY;\n            }\n        }\n        \n        if (delay < MIN_DELAY || delay > MAX_DELAY) {\n            revert InvalidDelay(delay);\n        }\n        \n        bytes32 actionHash = keccak256(abi.encodePacked(target, data, role, block.timestamp, msg.sender));\n        \n        if (scheduledActions[actionHash].executeTime != 0) {\n            revert AlreadyScheduled(actionHash);\n        }\n        \n        uint256 executeTime = block.timestamp + delay;\n        \n        ScheduledAction storage action = scheduledActions[actionHash];\n        action.actionHash = actionHash;\n        action.target = target;\n        action.data = data;\n        action.executeTime = executeTime;\n        action.executed = false;\n        action.cancelled = false;\n        action.proposer = msg.sender;\n        action.role = role;\n        \n        scheduledActionList.push(actionHash);\n        \n        emit ActionScheduled(actionHash, target, role, executeTime, msg.sender);\n        \n        return actionHash;\n    }\n    \n    /**\n     * @notice Execute a scheduled action\n     * @param actionHash The action to execute\n     */\n    function executeAction(bytes32 actionHash) external nonReentrant {\n        ScheduledAction storage action = scheduledActions[actionHash];\n        \n        if (action.executeTime == 0) revert ActionNotFound(actionHash);\n        if (action.executed) revert ActionAlreadyExecuted(actionHash);\n        if (action.cancelled) revert ActionAlreadyCancelled(actionHash);\n        if (block.timestamp < action.executeTime) {\n            revert ActionNotReady(actionHash, action.executeTime);\n        }\n        \n        // Check if caller has the required role\n        if (!roleManager.hasRole(action.role, msg.sender)) {\n            revert Unauthorized(actionHash);\n        }\n        \n        action.executed = true;\n        \n        // Execute the action\n        (bool success, bytes memory returnData) = action.target.call(action.data);\n        if (!success) {\n            // Revert with the original error\n            assembly {\n                let returnDataSize := mload(returnData)\n                revert(add(32, returnData), returnDataSize)\n            }\n        }\n        \n        emit ActionExecuted(actionHash, action.target);\n    }\n    \n    /**\n     * @notice Cancel a scheduled action\n     * @param actionHash The action to cancel\n     */\n    function cancelAction(bytes32 actionHash) external nonReentrant {\n        ScheduledAction storage action = scheduledActions[actionHash];\n        \n        if (action.executeTime == 0) revert ActionNotFound(actionHash);\n        if (action.executed) revert ActionAlreadyExecuted(actionHash);\n        if (action.cancelled) revert ActionAlreadyCancelled(actionHash);\n        \n        // Only proposer or role holder can cancel\n        if (msg.sender != action.proposer && !roleManager.hasRole(action.role, msg.sender)) {\n            revert Unauthorized(actionHash);\n        }\n        \n        action.cancelled = true;\n        \n        emit ActionCancelled(actionHash, msg.sender);\n    }\n    \n    /**\n     * @notice Set delay for a specific role\n     * @param role The role\n     * @param delay The delay in seconds\n     */\n    function setRoleDelay(bytes32 role, uint256 delay) external {\n        // Only admin can set delays\n        require(roleManager.hasRole(roleManager.DEFAULT_ADMIN_ROLE(), msg.sender), \"Not admin\");\n        \n        if (delay < MIN_DELAY || delay > MAX_DELAY) {\n            revert InvalidDelay(delay);\n        }\n        \n        uint256 oldDelay = roleDelays[role];\n        roleDelays[role] = delay;\n        \n        emit DelayUpdated(role, oldDelay, delay);\n    }\n    \n    /**\n     * @notice Check if an action can be executed\n     * @param actionHash The action hash\n     * @return canExecute True if action can be executed\n     */\n    function canExecuteAction(bytes32 actionHash) external view returns (bool) {\n        ScheduledAction storage action = scheduledActions[actionHash];\n        \n        return action.executeTime != 0 && \n               !action.executed && \n               !action.cancelled &&\n               block.timestamp >= action.executeTime;\n    }\n    \n    /**\n     * @notice Get action details\n     * @param actionHash The action hash\n     * @return target Target contract address\n     * @return data Encoded function call data\n     * @return executeTime When the action can be executed\n     * @return executed Whether the action has been executed\n     * @return cancelled Whether the action has been cancelled\n     * @return proposer The proposer address\n     * @return role The required role\n     */\n    function getActionDetails(bytes32 actionHash) external view returns (\n        address target,\n        bytes memory data,\n        uint256 executeTime,\n        bool executed,\n        bool cancelled,\n        address proposer,\n        bytes32 role\n    ) {\n        ScheduledAction storage action = scheduledActions[actionHash];\n        \n        return (\n            action.target,\n            action.data,\n            action.executeTime,\n            action.executed,\n            action.cancelled,\n            action.proposer,\n            action.role\n        );\n    }\n    \n    /**\n     * @notice Get all scheduled actions\n     * @return actions Array of scheduled action hashes\n     */\n    function getScheduledActions() external view returns (bytes32[] memory) {\n        return scheduledActionList;\n    }\n    \n    /**\n     * @notice Get pending actions (not executed, not cancelled, ready to execute)\n     * @return actions Array of pending action hashes\n     */\n    function getPendingActions() external view returns (bytes32[] memory) {\n        bytes32[] memory pending = new bytes32[](scheduledActionList.length);\n        uint256 count = 0;\n        \n        for (uint256 i = 0; i < scheduledActionList.length; i++) {\n            bytes32 actionHash = scheduledActionList[i];\n            ScheduledAction storage action = scheduledActions[actionHash];\n            \n            if (!action.executed && !action.cancelled && block.timestamp >= action.executeTime) {\n                pending[count] = actionHash;\n                count++;\n            }\n        }\n        \n        // Resize array to actual count\n        bytes32[] memory result = new bytes32[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = pending[i];\n        }\n        \n        return result;\n    }\n    \n    /**\n     * @notice Get delay for a role\n     * @param role The role\n     * @return delay The delay in seconds\n     */\n    function getRoleDelay(bytes32 role) external view returns (uint256) {\n        uint256 delay = roleDelays[role];\n        return delay == 0 ? DEFAULT_DELAY : delay;\n    }\n    \n    // ============ Internal Functions ============\n    \n    /**\n     * @notice Set default delays for different roles\n     */\n    function _setDefaultDelays() internal {\n        // Governance actions require longer delays\n        roleDelays[roleManager.GOVERNANCE_ROLE()] = 7 days;\n        roleDelays[roleManager.SECURITY_COUNCIL_ROLE()] = 2 days;\n        \n        // Token operations\n        roleDelays[roleManager.MINTER_ROLE()] = 24 hours;\n        roleDelays[roleManager.PAUSER_ROLE()] = 12 hours;\n        \n        // Upgrade operations\n        roleDelays[roleManager.UPGRADER_ROLE()] = 7 days;\n        \n        // Timelock operations\n        roleDelays[roleManager.PROPOSER_ROLE()] = 2 days;\n        roleDelays[roleManager.EXECUTOR_ROLE()] = 1 hours;\n        roleDelays[roleManager.CANCELLER_ROLE()] = 1 hours;\n    }\n}\n"
    },
    "contracts/utils/HyraDAOInitializer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"../core/HyraToken.sol\";\nimport \"../core/HyraGovernor.sol\";\nimport \"../core/HyraTimelock.sol\";\nimport \"../proxy/SecureProxyAdmin.sol\";\nimport \"../proxy/HyraProxyDeployer.sol\";\nimport \"../utils/TokenVesting.sol\";\nimport \"../interfaces/ITokenVesting.sol\";\nimport \"../security/SecureExecutorManager.sol\";\nimport \"../security/ProxyAdminValidator.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"../proxy/HyraTransparentUpgradeableProxy.sol\";\n\n/**\n * @title HyraDAOInitializer\n * @notice Helper contract for deploying and initializing the entire Hyra DAO system\n * @dev Deploys all contracts in the correct order with proper configuration \n */\ncontract HyraDAOInitializer {\n    // ============ Structs ============\n    struct DAOConfig {\n        // Token config\n        string tokenName;\n        string tokenSymbol;\n        uint256 initialSupply;\n        address vestingContract; // Replace initialHolder with vesting contract\n        // Timelock config\n        uint256 timelockDelay;\n        // Governor config\n        uint256 votingDelay;\n        uint256 votingPeriod;\n        uint256 proposalThreshold;\n        uint256 quorumPercentage;\n        // Security council\n        address[] securityCouncil;\n        // Multi-signature config\n        address[] multisigSigners;\n        uint256 requiredSignatures;\n        // Vesting config\n        VestingConfig vestingConfig;\n    }\n    \n    struct VestingConfig {\n        address[] beneficiaries;      // List of token recipients\n        uint256[] amounts;           // Token amount for each person\n        uint256[] startTimes;        // Vesting start time\n        uint256[] durations;         // Vesting duration\n        uint256[] cliffs;            // Cliff duration\n        bool[] revocable;            // Whether revocable\n        string[] purposes;           // Purpose of usage\n    }\n    \n    struct DeploymentResult {\n        // Implementations\n        address tokenImplementation;\n        address governorImplementation;\n        address timelockImplementation;\n        address vestingImplementation;\n        // Proxies\n        address tokenProxy;\n        address governorProxy;\n        address timelockProxy;\n        address vestingProxy;\n        // Infrastructure\n        address proxyAdmin;\n        address proxyDeployer;\n        address executorManager;\n        address proxyAdminValidator;\n    }\n    \n    // ============ Events ============\n    event DAODeployed(\n        address indexed deployer,\n        DeploymentResult deployment,\n        uint256 timestamp\n    );\n    \n    // ============ Errors ============\n    error InvalidConfig();\n    error DeploymentFailed();\n    error InitializationFailed();\n    \n    /**\n     * @notice Deploy and initialize the complete DAO system\n     * @param config Configuration parameters\n     * @return result Deployment addresses\n     */\n    function deployDAO(DAOConfig memory config) \n        external \n        returns (DeploymentResult memory result) \n    {\n        // Validate config\n        if (bytes(config.tokenName).length == 0 || \n            bytes(config.tokenSymbol).length == 0 ||\n            config.vestingContract == address(0)) {\n            revert InvalidConfig();\n        }\n        \n        // 1. Deploy SecureProxyAdmin (with multisig wallet)\n        result.proxyAdmin = address(new SecureProxyAdmin(address(this), config.requiredSignatures));\n        \n        // 2. Deploy ProxyDeployer\n        result.proxyDeployer = address(new HyraProxyDeployer());\n        \n        // 2.1 Deploy SecureExecutorManager\n        address[] memory initialExecutors = new address[](1);\n        initialExecutors[0] = address(this); // Temporary executor\n        \n        result.executorManager = IHyraProxyDeployer(result.proxyDeployer).deployProxy(\n            address(new SecureExecutorManager()),\n            result.proxyAdmin,\n            abi.encodeWithSelector(\n                SecureExecutorManager.initialize.selector,\n                address(this),\n                initialExecutors\n            ),\n            \"EXECUTOR_MANAGER\"\n        );\n        \n        // 2.2 Deploy ProxyAdminValidator\n        result.proxyAdminValidator = IHyraProxyDeployer(result.proxyDeployer).deployProxy(\n            address(new ProxyAdminValidator()),\n            result.proxyAdmin,\n            abi.encodeWithSelector(\n                ProxyAdminValidator.initialize.selector,\n                address(this)\n            ),\n            \"PROXY_ADMIN_VALIDATOR\"\n        );\n        \n        // 3. Deploy Timelock implementation\n        result.timelockImplementation = address(new HyraTimelock());\n        \n        // 4. Deploy Timelock proxy with initial configuration\n        address[] memory proposers = new address[](1);\n        proposers[0] = address(this); // Temporary proposer\n        \n        address[] memory executors = new address[](1);\n        executors[0] = address(this); // Temporary executor\n        \n        bytes memory timelockInitData = abi.encodeWithSelector(\n            HyraTimelock.initialize.selector,\n            config.timelockDelay,\n            proposers,\n            executors,\n            address(this) // Set contract as temporary admin\n        );\n        \n        result.timelockProxy = IHyraProxyDeployer(result.proxyDeployer).deployProxy(\n            result.timelockImplementation,\n            result.proxyAdmin,\n            timelockInitData,\n            \"TIMELOCK\"\n        );\n        \n        // 5. Deploy Vesting implementation\n        result.vestingImplementation = address(new TokenVesting());\n        \n        // 6. Deploy Vesting proxy (will be initialized after token deployment)\n        bytes memory vestingInitData = \"\";\n        \n        result.vestingProxy = IHyraProxyDeployer(result.proxyDeployer).deployProxy(\n            result.vestingImplementation,\n            result.proxyAdmin,\n            vestingInitData,\n            \"VESTING\"\n        );\n        \n        // 7. Deploy Token implementation\n        result.tokenImplementation = address(new HyraToken());\n        \n        // 8. Deploy Token proxy with vesting contract address\n        bytes memory tokenInitData = abi.encodeWithSelector(\n            HyraToken.initialize.selector,\n            config.tokenName,\n            config.tokenSymbol,\n            config.initialSupply,\n            result.vestingProxy, // Vesting contract receives initial tokens\n            result.timelockProxy // Timelock is the owner\n        );\n        \n        result.tokenProxy = IHyraProxyDeployer(result.proxyDeployer).deployProxy(\n            result.tokenImplementation,\n            result.proxyAdmin,\n            tokenInitData,\n            \"TOKEN\"\n        );\n        \n        // 9. Initialize Vesting contract with token address (temporary owner = initializer)\n        ITokenVesting(result.vestingProxy).initialize(result.tokenProxy, address(this));\n        \n        // 10. Deploy Governor implementation\n        result.governorImplementation = address(new HyraGovernor());\n        \n        // 11. Deploy Governor proxy\n        uint256 quorumArg = config.quorumPercentage > 100 ? config.quorumPercentage / 100 : config.quorumPercentage;\n        bytes memory governorInitData = abi.encodeWithSelector(\n            HyraGovernor.initialize.selector,\n            IVotes(result.tokenProxy),\n            TimelockControllerUpgradeable(payable(result.timelockProxy)),\n            config.votingDelay,\n            config.votingPeriod,\n            config.proposalThreshold,\n            quorumArg\n        );\n        \n        result.governorProxy = IHyraProxyDeployer(result.proxyDeployer).deployProxy(\n            result.governorImplementation,\n            result.proxyAdmin,\n            governorInitData,\n            \"GOVERNOR\"\n        );\n        \n        // 12. Setup executor manager and proxy admin validator in timelock (requires admin privileges)\n        HyraTimelock(payable(result.timelockProxy)).setExecutorManager(SecureExecutorManager(result.executorManager));\n        HyraTimelock(payable(result.timelockProxy)).setProxyAdminValidator(ProxyAdminValidator(result.proxyAdminValidator));\n\n        // 12.1 Configure roles (grants to governor, executor manager, council; then revokes/renounces temporary roles)\n        _configureRoles(result, config);\n\n        // 12.2 Authorize the deployed proxy admin in the validator (initializer still has validator role)\n        ProxyAdminValidator(result.proxyAdminValidator).authorizeProxyAdmin(\n            result.proxyAdmin,\n            \"HyraDAO SecureProxyAdmin\",\n            result.timelockProxy, // Owner is the timelock\n            \"Main proxy admin for Hyra DAO system\"\n        );\n        \n        // 13. Setup vesting schedules\n        _setupVestingSchedules(result, config);\n        // 13.1 Transfer vesting ownership to Timelock after setup\n        TokenVesting(result.vestingProxy).transferOwnership(result.timelockProxy);\n        \n        // 14. Add proxies to SecureProxyAdmin\n        SecureProxyAdmin(result.proxyAdmin).addProxy(result.tokenProxy, \"HyraToken\");\n        SecureProxyAdmin(result.proxyAdmin).addProxy(result.governorProxy, \"HyraGovernor\");\n        SecureProxyAdmin(result.proxyAdmin).addProxy(result.timelockProxy, \"HyraTimelock\");\n        SecureProxyAdmin(result.proxyAdmin).addProxy(result.vestingProxy, \"TokenVesting\");\n        \n        // 14.1 Grant SecureProxyAdmin roles to timelock so DAO can manage upgrades\n        {\n            SecureProxyAdmin spa = SecureProxyAdmin(result.proxyAdmin);\n            bytes32 ADMIN = spa.DEFAULT_ADMIN_ROLE();\n            bytes32 GOV = spa.GOVERNANCE_ROLE();\n            bytes32 MULTI = spa.MULTISIG_ROLE();\n            spa.grantRole(ADMIN, result.timelockProxy);\n            spa.grantRole(GOV, result.timelockProxy);\n            spa.grantRole(MULTI, result.timelockProxy);\n        }\n        \n        // 15. Transfer SecureProxyAdmin ownership to Timelock\n        SecureProxyAdmin(result.proxyAdmin).transferOwnership(result.timelockProxy);\n        \n        // 16. Handover admin roles for security contracts from initializer to timelock\n        _handoverSecurityContracts(result);\n        \n        // FIXED: Emit event after all external calls are complete\n        emit DAODeployed(msg.sender, result, block.timestamp);\n        \n        return result;\n    }\n    \n    /**\n     * @notice Configure roles and permissions\n     */\n    function _configureRoles(\n        DeploymentResult memory result,\n        DAOConfig memory config\n    ) private {\n        HyraTimelock timelock = HyraTimelock(payable(result.timelockProxy));\n        \n        // Get role identifiers\n        bytes32 PROPOSER_ROLE = timelock.PROPOSER_ROLE();\n        bytes32 EXECUTOR_ROLE = timelock.EXECUTOR_ROLE();\n        bytes32 CANCELLER_ROLE = timelock.CANCELLER_ROLE();\n        bytes32 DEFAULT_ADMIN_ROLE = timelock.DEFAULT_ADMIN_ROLE();\n        \n        // Grant proposer role to Governor\n        timelock.grantRole(PROPOSER_ROLE, result.governorProxy);\n        \n        // Grant executor role to SecureExecutorManager\n        // This replaces the problematic address(0) executor\n        timelock.grantRole(EXECUTOR_ROLE, result.executorManager);\n        \n        // FIXED: Batch role grants to avoid external calls in loop\n        // Setup security council - batch the role grants\n        address[] memory securityCouncil = config.securityCouncil;\n        uint256 councilLength = securityCouncil.length;\n        \n        for (uint256 i = 0; i < councilLength; i++) {\n            // Grant canceller role\n            timelock.grantRole(CANCELLER_ROLE, securityCouncil[i]);\n            \n            // Note: Adding to governor security council would need to be done\n            // through governance proposal after deployment as governor is owned by timelock\n        }\n        \n        // Revoke temporary roles granted to initializer during timelock initialization\n        timelock.revokeRole(PROPOSER_ROLE, address(this));\n        timelock.revokeRole(EXECUTOR_ROLE, address(this));\n        \n        // Renounce admin role from initializer after cleanup\n        timelock.renounceRole(DEFAULT_ADMIN_ROLE, address(this));\n    }\n\n    /**\n     * @notice Transfer admin control of security contracts to the timelock and renounce from initializer\n     */\n    function _handoverSecurityContracts(DeploymentResult memory result) private {\n        // SecureExecutorManager role handover\n        SecureExecutorManager sem = SecureExecutorManager(result.executorManager);\n        bytes32 SEM_ADMIN = sem.DEFAULT_ADMIN_ROLE();\n        bytes32 SEM_MANAGER = sem.MANAGER_ROLE();\n        bytes32 SEM_EMERGENCY = sem.EMERGENCY_ROLE();\n\n        // Grant timelock full control\n        sem.grantRole(SEM_ADMIN, result.timelockProxy);\n        sem.grantRole(SEM_MANAGER, result.timelockProxy);\n        sem.grantRole(SEM_EMERGENCY, result.timelockProxy);\n\n        // Optional: keep initializer as an authorized executor until DAO adds others via governance\n        // Do NOT remove initializer executor here to avoid locking execution if none exists yet\n\n        // Renounce initializer privileges\n        sem.renounceRole(SEM_MANAGER, address(this));\n        sem.renounceRole(SEM_EMERGENCY, address(this));\n        sem.renounceRole(SEM_ADMIN, address(this));\n\n        // ProxyAdminValidator role handover\n        ProxyAdminValidator pav = ProxyAdminValidator(result.proxyAdminValidator);\n        bytes32 PAV_ADMIN = pav.DEFAULT_ADMIN_ROLE();\n        bytes32 PAV_VALIDATOR = pav.VALIDATOR_ROLE();\n\n        // Grant timelock control\n        pav.grantRole(PAV_ADMIN, result.timelockProxy);\n        pav.grantRole(PAV_VALIDATOR, result.timelockProxy);\n\n        // Renounce initializer roles\n        pav.renounceRole(PAV_VALIDATOR, address(this));\n        pav.renounceRole(PAV_ADMIN, address(this));\n    }\n    \n    /**\n     * @notice Setup vesting schedules\n     */\n    function _setupVestingSchedules(\n        DeploymentResult memory result,\n        DAOConfig memory config\n    ) private {\n        VestingConfig memory vestingConfig = config.vestingConfig;\n        \n        // Check vesting configuration\n        require(\n            vestingConfig.beneficiaries.length > 0 &&\n            vestingConfig.beneficiaries.length == vestingConfig.amounts.length &&\n            vestingConfig.beneficiaries.length == vestingConfig.startTimes.length &&\n            vestingConfig.beneficiaries.length == vestingConfig.durations.length &&\n            vestingConfig.beneficiaries.length == vestingConfig.cliffs.length &&\n            vestingConfig.beneficiaries.length == vestingConfig.revocable.length &&\n            vestingConfig.beneficiaries.length == vestingConfig.purposes.length,\n            \"Invalid vesting config\"\n        );\n        \n        ITokenVesting vesting = ITokenVesting(result.vestingProxy);\n        \n        // FIXED: Cache array length to avoid external calls in loop\n        uint256 beneficiariesLength = vestingConfig.beneficiaries.length;\n        \n        // Create vesting schedule for each beneficiary\n        for (uint256 i = 0; i < beneficiariesLength; i++) {\n            // FIXED: Handle return value from external call\n            try vesting.createVestingSchedule(\n                vestingConfig.beneficiaries[i],\n                vestingConfig.amounts[i],\n                vestingConfig.startTimes[i],\n                vestingConfig.durations[i],\n                vestingConfig.cliffs[i],\n                vestingConfig.revocable[i],\n                vestingConfig.purposes[i]\n            ) {\n                // Success - continue to next iteration\n            } catch {\n                // Log error and continue - don't fail entire deployment\n                // In production, consider emitting an event for failed vesting schedule creation\n                continue;\n            }\n        }\n    }\n    \n    /**\n     * @notice Verify deployment was successful\n     * @param result Deployment result to verify\n     * @return success True if all contracts deployed correctly\n     */\n    function verifyDeployment(DeploymentResult memory result) \n        external \n        view \n        returns (bool success) \n    {\n        // Check all addresses are non-zero\n        success = result.tokenImplementation != address(0) &&\n                 result.governorImplementation != address(0) &&\n                 result.timelockImplementation != address(0) &&\n                 result.vestingImplementation != address(0) &&\n                 result.tokenProxy != address(0) &&\n                 result.governorProxy != address(0) &&\n                 result.timelockProxy != address(0) &&\n                 result.vestingProxy != address(0) &&\n                 result.proxyAdmin != address(0) &&\n                 result.proxyDeployer != address(0) &&\n                 result.executorManager != address(0) &&\n                 result.proxyAdminValidator != address(0);\n        \n        if (!success) return false;\n        \n        // Verify proxies point to correct implementations\n        // Note: This verification is commented out for simplicity\n        // In production, you would verify the proxy implementations\n        \n        return success;\n    }\n    \n    /**\n     * @notice Calculate deployment addresses in advance\n     * @param deployer Address that will deploy\n     * @param nonce Starting nonce\n     * @return addresses Predicted addresses\n     */\n    function calculateDeploymentAddresses(\n        address deployer,\n        uint256 nonce\n    ) external pure returns (DeploymentResult memory addresses) {\n        addresses.proxyAdmin = computeAddress(deployer, nonce);\n        addresses.proxyDeployer = computeAddress(deployer, nonce + 1);\n        addresses.timelockImplementation = computeAddress(deployer, nonce + 2);\n        // Proxy addresses would be computed from ProxyDeployer's nonce\n        // This is simplified - actual implementation would need ProxyDeployer's address\n    }\n    \n    /**\n     * @notice Compute contract address from deployer and nonce\n     */\n    function computeAddress(address deployer, uint256 nonce) \n        private \n        pure \n        returns (address) \n    {\n        if (nonce == 0) {\n            return address(uint160(uint256(keccak256(abi.encodePacked(\n                bytes1(0xd6),\n                bytes1(0x94),\n                deployer,\n                bytes1(0x80)\n            )))));\n        }\n        if (nonce <= 0x7f) {\n            return address(uint160(uint256(keccak256(abi.encodePacked(\n                bytes1(0xd6),\n                bytes1(0x94),\n                deployer,\n                uint8(nonce)\n            )))));\n        }\n        if (nonce <= 0xff) {\n            return address(uint160(uint256(keccak256(abi.encodePacked(\n                bytes1(0xd7),\n                bytes1(0x94),\n                deployer,\n                bytes1(0x81),\n                uint8(nonce)\n            )))));\n        }\n        // For nonces > 255, revert as RLP encoding becomes complex\n        revert(\"Nonce too large for address computation\");\n    }\n}"
    },
    "contracts/utils/TokenVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title TokenVesting\n * @notice Gradual token distribution contract with high security\n * @dev Solves centralization issues in initial token distribution\n */\ncontract TokenVesting is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    \n    // ============ Structs ============\n    struct VestingSchedule {\n        bool initialized;        // Whether initialized\n        bool revocable;         // Whether revocable\n        uint256 totalAmount;    // Total tokens to be vested\n        uint256 releasedAmount; // Amount of tokens already released\n        uint256 startTime;      // Vesting start time\n        uint256 duration;       // Vesting duration (seconds)\n        uint256 cliff;          // Cliff duration (seconds)\n        address beneficiary;    // Token recipient\n        string purpose;         // Purpose of token usage\n    }\n    \n    // ============ State Variables ============\n    IERC20 public token;                              // Token being vested\n    mapping(bytes32 => VestingSchedule) public vestingSchedules; // Vesting schedules\n    mapping(address => uint256) public totalVestedAmount;        // Total vested tokens per person\n    mapping(address => uint256) public totalReleasedAmount;      // Total released tokens per person\n    \n    uint256 public totalVestingSchedules;             // Total number of vesting schedules\n    uint256 public constant MIN_VESTING_DURATION = 30 days;     // Minimum vesting duration\n    uint256 public constant MAX_VESTING_DURATION = 10 * 365 days; // Maximum vesting duration (10 years)\n    \n    // ============ Events ============\n    event VestingScheduleCreated(\n        bytes32 indexed vestingScheduleId,\n        address indexed beneficiary,\n        uint256 totalAmount,\n        uint256 startTime,\n        uint256 duration,\n        uint256 cliff,\n        string purpose\n    );\n    \n    event TokensReleased(\n        bytes32 indexed vestingScheduleId,\n        address indexed beneficiary,\n        uint256 amount,\n        uint256 timestamp\n    );\n    \n    event VestingScheduleRevoked(\n        bytes32 indexed vestingScheduleId,\n        address indexed beneficiary,\n        uint256 revokedAmount,\n        uint256 timestamp\n    );\n    \n    event EmergencyWithdraw(address indexed token, uint256 amount, uint256 timestamp);\n    \n    // ============ Errors ============\n    error InvalidAddress();\n    error InvalidAmount();\n    error InvalidDuration();\n    error InvalidCliff();\n    error VestingScheduleNotFound();\n    error VestingScheduleAlreadyExists();\n    error NotRevocable();\n    error AlreadyRevoked();\n    error InsufficientTokenBalance();\n    error NoTokensToRelease();\n    error UnauthorizedAccess();\n    \n    // ============ Modifiers ============\n    modifier validAddress(address _addr) {\n        if (_addr == address(0)) revert InvalidAddress();\n        _;\n    }\n    \n    modifier validAmount(uint256 _amount) {\n        if (_amount == 0) revert InvalidAmount();\n        _;\n    }\n    \n    modifier validDuration(uint256 _duration) {\n        if (_duration < MIN_VESTING_DURATION || _duration > MAX_VESTING_DURATION) {\n            revert InvalidDuration();\n        }\n        _;\n    }\n    \n    modifier validCliff(uint256 _cliff, uint256 _duration) {\n        if (_cliff > _duration) revert InvalidCliff();\n        _;\n    }\n    \n    modifier vestingScheduleExists(bytes32 _vestingScheduleId) {\n        if (!vestingSchedules[_vestingScheduleId].initialized) {\n            revert VestingScheduleNotFound();\n        }\n        _;\n    }\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    \n    /**\n     * @notice Initialize vesting contract\n     * @param _token ERC20 token address\n     * @param _owner Contract owner (usually multi-sig)\n     */\n    function initialize(address _token, address _owner) \n        public \n        initializer \n        validAddress(_token) \n        validAddress(_owner) \n    {\n        __Ownable_init(_owner);\n        __ReentrancyGuard_init();\n        \n        token = IERC20(_token);\n    }\n    \n    /**\n     * @notice Create new vesting schedule\n     * @param _beneficiary Token recipient\n     * @param _totalAmount Total token amount\n     * @param _startTime Start time\n     * @param _duration Vesting duration\n     * @param _cliff Cliff duration\n     * @param _revocable Whether revocable\n     * @param _purpose Purpose of usage\n     * @return vestingScheduleId Vesting schedule ID\n     */\n    function createVestingSchedule(\n        address _beneficiary,\n        uint256 _totalAmount,\n        uint256 _startTime,\n        uint256 _duration,\n        uint256 _cliff,\n        bool _revocable,\n        string memory _purpose\n    ) \n        external \n        onlyOwner \n        validAddress(_beneficiary) \n        validAmount(_totalAmount)\n        validDuration(_duration)\n        validCliff(_cliff, _duration)\n        returns (bytes32 vestingScheduleId)\n    {\n        // Check contract token balance\n        if (token.balanceOf(address(this)) < _totalAmount) {\n            revert InsufficientTokenBalance();\n        }\n        \n        // Create unique ID for vesting schedule\n        vestingScheduleId = keccak256(abi.encodePacked(\n            _beneficiary,\n            _totalAmount,\n            _startTime,\n            _duration,\n            _cliff,\n            _purpose,\n            block.timestamp\n        ));\n        \n        // Check if vesting schedule already exists\n        if (vestingSchedules[vestingScheduleId].initialized) {\n            revert VestingScheduleAlreadyExists();\n        }\n        \n        // Create vesting schedule\n        vestingSchedules[vestingScheduleId] = VestingSchedule({\n            initialized: true,\n            revocable: _revocable,\n            totalAmount: _totalAmount,\n            releasedAmount: 0,\n            startTime: _startTime,\n            duration: _duration,\n            cliff: _cliff,\n            beneficiary: _beneficiary,\n            purpose: _purpose\n        });\n        \n        // Update statistics\n        totalVestingSchedules++;\n        totalVestedAmount[_beneficiary] += _totalAmount;\n        \n        emit VestingScheduleCreated(\n            vestingScheduleId,\n            _beneficiary,\n            _totalAmount,\n            _startTime,\n            _duration,\n            _cliff,\n            _purpose\n        );\n        \n        return vestingScheduleId;\n    }\n    \n    /**\n     * @notice Release vested tokens\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return releasedAmount Amount of tokens released\n     */\n    function release(bytes32 _vestingScheduleId) \n        external \n        nonReentrant \n        vestingScheduleExists(_vestingScheduleId)\n        returns (uint256 releasedAmount)\n    {\n        VestingSchedule storage schedule = vestingSchedules[_vestingScheduleId];\n        \n        // Calculate releasable token amount\n        releasedAmount = _calculateReleasableAmount(schedule);\n        \n        if (releasedAmount == 0) {\n            revert NoTokensToRelease();\n        }\n        \n        // Update state\n        schedule.releasedAmount += releasedAmount;\n        totalReleasedAmount[schedule.beneficiary] += releasedAmount;\n        \n        // Transfer tokens\n        require(\n            token.transfer(schedule.beneficiary, releasedAmount),\n            \"Token transfer failed\"\n        );\n        \n        emit TokensReleased(\n            _vestingScheduleId,\n            schedule.beneficiary,\n            releasedAmount,\n            block.timestamp\n        );\n        \n        return releasedAmount;\n    }\n    \n    /**\n     * @notice Release tokens for all schedules of a beneficiary\n     * @param _beneficiary Token recipient\n     * @return totalReleased Total amount of tokens released\n     */\n    function releaseAllForBeneficiary(address _beneficiary) \n        external \n        nonReentrant \n        validAddress(_beneficiary)\n        returns (uint256 totalReleased)\n    {\n        totalReleased = 0;\n        \n        // Note: In practice, need to implement way to find all vesting schedules of a beneficiary\n        // This is a simple implementation, may need improvement\n        for (uint256 i = 0; i < totalVestingSchedules; i++) {\n            // Detailed implementation needs additional mapping to track vesting schedules per beneficiary\n        }\n        \n        return totalReleased;\n    }\n    \n    /**\n     * @notice Revoke vesting schedule (only when revocable = true)\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return revokedAmount Amount of tokens revoked\n     */\n    function revoke(bytes32 _vestingScheduleId) \n        external \n        onlyOwner \n        vestingScheduleExists(_vestingScheduleId)\n        returns (uint256 revokedAmount)\n    {\n        VestingSchedule storage schedule = vestingSchedules[_vestingScheduleId];\n        \n        if (!schedule.revocable) {\n            revert NotRevocable();\n        }\n        \n        // Calculate remaining unvested tokens\n        uint256 vestedAmount = _calculateVestedAmount(schedule);\n        revokedAmount = schedule.totalAmount - vestedAmount;\n        \n        if (revokedAmount == 0) {\n            revert AlreadyRevoked();\n        }\n        \n        // Update state\n        schedule.totalAmount = vestedAmount;\n        totalVestedAmount[schedule.beneficiary] -= revokedAmount;\n        \n        emit VestingScheduleRevoked(\n            _vestingScheduleId,\n            schedule.beneficiary,\n            revokedAmount,\n            block.timestamp\n        );\n        \n        return revokedAmount;\n    }\n    \n    /**\n     * @notice Emergency token withdrawal (owner only)\n     * @param _amount Amount of tokens to withdraw\n     */\n    function emergencyWithdraw(uint256 _amount) \n        external \n        onlyOwner \n        nonReentrant\n    {\n        require(token.transfer(owner(), _amount), \"Token transfer failed\");\n        emit EmergencyWithdraw(address(token), _amount, block.timestamp);\n    }\n    \n    // ============ View Functions ============\n    \n    /**\n     * @notice Calculate releasable token amount\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return Releasable token amount\n     */\n    function getReleasableAmount(bytes32 _vestingScheduleId) \n        external \n        view \n        vestingScheduleExists(_vestingScheduleId)\n        returns (uint256)\n    {\n        return _calculateReleasableAmount(vestingSchedules[_vestingScheduleId]);\n    }\n    \n    /**\n     * @notice Calculate vested token amount\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return Vested token amount\n     */\n    function getVestedAmount(bytes32 _vestingScheduleId) \n        external \n        view \n        vestingScheduleExists(_vestingScheduleId)\n        returns (uint256)\n    {\n        return _calculateVestedAmount(vestingSchedules[_vestingScheduleId]);\n    }\n    \n    /**\n     * @notice Get detailed vesting schedule information\n     * @param _vestingScheduleId Vesting schedule ID\n     * @return schedule Detailed information\n     */\n    function getVestingSchedule(bytes32 _vestingScheduleId) \n        external \n        view \n        vestingScheduleExists(_vestingScheduleId)\n        returns (VestingSchedule memory schedule)\n    {\n        return vestingSchedules[_vestingScheduleId];\n    }\n    \n    /**\n     * @notice Calculate total releasable tokens for a beneficiary\n     * @param _beneficiary Token recipient\n     * @return Total releasable token amount\n     */\n    function getTotalReleasableAmount(address _beneficiary) \n        external \n        view \n        returns (uint256)\n    {\n        // Implementation needs additional mapping to track vesting schedules per beneficiary\n        return 0;\n    }\n    \n    // ============ Internal Functions ============\n    \n    /**\n     * @notice Calculate releasable token amount\n     * @param schedule Vesting schedule\n     * @return Releasable token amount\n     */\n    function _calculateReleasableAmount(VestingSchedule storage schedule) \n        internal \n        view \n        returns (uint256)\n    {\n        uint256 vestedAmount = _calculateVestedAmount(schedule);\n        return vestedAmount - schedule.releasedAmount;\n    }\n    \n    /**\n     * @notice Calculate vested token amount\n     * @param schedule Vesting schedule\n     * @return Vested token amount\n     */\n    function _calculateVestedAmount(VestingSchedule storage schedule) \n        internal \n        view \n        returns (uint256)\n    {\n        // Check start time\n        if (block.timestamp < schedule.startTime) {\n            return 0;\n        }\n        \n        // Check cliff time\n        if (block.timestamp < schedule.startTime + schedule.cliff) {\n            return 0;\n        }\n        \n        // Check end time\n        if (block.timestamp >= schedule.startTime + schedule.duration) {\n            return schedule.totalAmount;\n        }\n        \n        // Calculate linear vesting\n        uint256 timeElapsed = block.timestamp - schedule.startTime;\n        return (schedule.totalAmount * timeElapsed) / schedule.duration;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "cancun",
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}